\section{Using Utool}  \label{sec:operations}

In the current release, Utool supports six commands: \verb?solve?,
\verb?solvable?, \verb?classify?, \verb?convert?, \verb?server?, and
\verb?display?. Each of these commands can be used from the
command-line or in the Utool Server (but running the \verb?server?
command in the Utool Server doesn't do anything). In addition, Utool
supports some auxiliary pseudo-commands for displaying help and for
starting the Utool Server.

In this section, we describe these commands in some detail.


\subsection{Command-line interface}
When Utool is run from the command-line, it executes the single
command you specify on the command line and then exits. For instance,
the following call executes one \verb?solvable? command and outputs
some information about it:

\begin{verbatim}
$ java -jar Utool.jar solvable -s chain-3.clls
\end{verbatim}
% $

Commands typically require \emph{arguments} (in the example, the
filename \verb?chain-3.clls? of the USR that we want to solve), and
accept certain \emph{options} (here, the \verb?-s? option, which
instructs Utool to display statistical information). These arguments
and options are written after the command on the command line.

You can get help on using the different commands by running Utool with
the \verb?help? command.


\subsection{Server mode}

Alternatively, you can run Utool in server mode. In this mode, it will
not execute any commands at first. Instead, it will accept network
connections on a specific socket. Each time it is sent a command on
this socket, it will execute this command, send the results back over
the socket, and then close the socket. But the same Utool process
keeps running and can execute many commands during its lifetime. 

You start Utool in server mode by making Utool execute the
\verb?server? command:

\begin{verbatim}
$ java -jar Utool.jar server
\end{verbatim}
%$

The server doesn't output anything on the console on which you started
it -- unless you specified the \verb?--logging? command-line option
and no name for the logfile, in which case it will write some
information to standard error. 

By default, the server will listen for socket connections on port
2802, but the port can be specified using the \verb?--port?
option. You communicate with it by sending it XML queries and
accepting the XML results. You start by sending a query of the
following form:

\begin{verbatim}
<utool cmd="..." (more options)>
  (arguments of the command)
</utool>
\end{verbatim}

Next, you shut down the half of the socket that is responsible for
sending data to the server. Many socket libraries (e.g.\ the standard
libraries for C and Perl) offer a \verb?shutdown? function, which you
should use to shut down the socket for sending. The Utool Server will
recognise this and start processing the command. Notice that
\verb?shutdown? is different from \verb?close? because it only closes
one direction of the socket; you can't close the socket yet because
you still need to receive the response from the server.

If the command is executed successfully, the server will respond with
a message of the following form:

\begin{verbatim}
<result .... />
\end{verbatim}

The particular attributes of this element depend on the command, and
are described below. If an error occurred, the response will be a
message of the following form instead:

\begin{verbatim}
<error code="..." explanation="..." />
\end{verbatim}

Here the ``code'' attribute will be a numeric error code, and the
``explanation'' attribute will be a plain-text explanation of the
error that occurred.

If you just use Utool for a single call or experimentation, the
command-line mode will typically be easier to use. However, if you
need to process many Utool commands from a programme, it can be
dramatically more efficient to keep a single Utool Server process
running and send the commands to the server. This is because running a
Java process incurs an overhead for starting up the virtual machine
and loading the libraries. In addition, the just-in-time compilation
really starts to pay off only after a little while (say, after solving
two or three graphs), i.e.\ you will only ever achieve an efficiency
comparable to the C++ implementation in the server mode.


\subsection{Passing USRs}

Most commands require the user to specify an USR that should be
processed.

In command-line mode, you pass a specification of the USR as a
command-line argument. Most input codecs interpret this specification
string as the filename from which the USR should be read; in the
example above, we used the file name \verb?chain-3.clls?. However, it
is up to the input codec to decide how the argument string should be
interpreted; the \verb?chain? codec, for example, interprets the
string as the chain length and not as a filename.

In server mode, you can't pass a filename because the server may run
on a different machine than the client and may not have access to its
filesystem. Instead, you pass the USR directly as an attribute of
\verb?usr? element that is embedded into the \verb?utool? element,
like so:

\begin{verbatim}
<utool command="solvable">
  <usr codec="domcon-oz" string="[label(x f(y)) ...]" />
</utool>
\end{verbatim}

Notice that the attribute values must be valid XML attribute
strings. This means that you must replace special characters by
their respective character entities (see also
Section~\ref{sec:practice} for tips on this).


\subsection{Exit codes}

Each execution of a Utool command returns an \emph{exit code}. The
command-line version of Utool will return this as the programme exit
code, which you can access e.g.\ in the \texttt{\$?} variable in a
Bash shell. The server version will return the exit code in the
\verb?code? attribute in the responses for many commands (and always
when it reports an error).

Exit codes are numbers between 0 and 255. They are split up into
ranges with different meanings as follows:

\begin{tabular}{l|l}
exit codes & meaning \\\hline
0 -- 127 & command was executed successfully \\
128 -- 191 & an error occurred in the main programme \\
192 -- 223 & an error occurred in the input codec \\
224 -- 255 & an error occurred in the output codec
\end{tabular}

The exit codes for successful termination of a command are documented
with the commands below. The exit codes signifying codec errors are
documented with the codecs in Section~\ref{sec:codecs}. The exit codes
for the main programme are as follows:

\begin{tabular}{l|l}
exit codes & meaning \\\hline
128 & \todo{document this}
\end{tabular}




\subsection{The commands supported by Utool}

We will now go through the six main commands and describe what each
command does and what options it takes.


\subsubsection{Solvable}

This command converts the input USR into a dominance graph and checks
whether this graph is solvable, i.e.\ has any
solutions. Linguistically, this corresponds to checking whether the
sentence has any readings (ideally, it should!).

Solvability is determined by computing a dominance chart as described
in \cite{KolTha05b}. This is typically much more efficient than
actually \emph{solving} the graph, i.e.\ enumerating its solved forms,
because the chart is exponentially smaller than the set of all solved
forms. This command only makes a yes/no decision about solvability and
thus doesn't have to enumerate all the solved forms. If you want them,
see the ``solve'' command below.


\paragraph{Result.}
In command-line mode, the Utool process will terminate with an exit
code of 1 if the graph was solvable. It will terminate with an exit
code of 0 if it wasn't. 

In server mode, Utool will send a reply of the following form:
\begin{verbatim}
<result solvable='true' fragments='7' count='5' chartsize='10' time='30' />
\end{verbatim}

The \verb?solvable? attribute contains the string \verb?true? if the
graph was solvable, and \verb?false? otherwise. The other attributes
contain statistical information: the number of fragments of the graph,
the number of solved forms, the number of splits in the chart, and the
time in milliseconds it took to compute the chart.


\paragraph{Options.}
The \verb?solvable? command can take the following options:
\begin{description}
\item[input-codec:] You can specify an input codec for this
command. By default, the command-line version will try to guess the
appropriate input codec from the filename extension. If this is not
possible (or in server mode), you must specify the input codec by name
explicitly.

In command-line mode, specify the input codec with the option
\verb?--input-codec <codecname>? or \verb?-I <codecname>?. In server
mode, specify it as the \verb?codec? attribute of the \verb?usr?
element.
\item[display-statistics:] You can make Utool display more detailed
statistics when you call it on the command-line by passing the
\verb?--display-statistics? or \verb?-s? option. All such statistics
information will be written to standard error.
\end{description}



\subsubsection{Solve}

This command converts the input USR into a dominance graph, computes
the solved forms of this graph, and outputs them using the given
output codec. It computes a dominance chart, and if the graph was
solvable, proceeds to enumerate all solved forms.


\paragraph{Result.}
In command-line mode, Utool will output all solved forms. By default,
it will write them to standard output, but there is a command-line
option for redirecting them into a file. This command will always
terminate with an exit code of 0 if no errors occurred.

In server mode, Utool will send a reply of the following form:
\begin{verbatim}
<result solvable='true' fragments='7' count='5' chartsize='10'
        time-chart='30' time-extraction='100'>
  <solution string='....' />
  <solution string='....' />
</result>
\end{verbatim}

The attributes of the \verb?result? element are as for the
\verb?solvable? command, except that the runtime is now reported
separately for computing the chart and for enumerating (extracting)
the solved forms. The solutions are returned in attributes of
\verb?solution? elements below the \verb?result? element. Notice that
you may need to resolve XML character entities that were used in the
attribute value strings.

\paragraph{Options.}
The \verb?solve? command can take the following options:
\begin{description}
\item[input-codec:] see the \verb?solvable? command
\item[output-codec:] You must specify which output codec should be
used to encode the solved forms. The command-line tool will try to
guess the output codec from the output filename if you specify one. If
this doesn't work, it will try to use the output codec with the same
name as the input codec, if it exists. If this doesn't work either (or
if you want to override the default, or if you use the server mode),
you must specify the output codec explicitly by name with this option.

In command-line mode, specify the output codec with the option
\verb?--output-codec <codecname>? or \verb?-O <codecname>?. In server
mode, specify it by passing the codec name as the \verb?output-codec?
attribute of the main \verb?utool? element.

\item[output:] By default, the command-line tool will write the
encoded solved forms to standard error. You can override this by
specifying an output file with the option \verb?--output <filename>?
or \verb?-o <filename>?. This option is not applicable in server
mode because it doesn't write into files anyway.

\item[no-output:] You can instruct Utool not to output the actual
solved forms by specifying the ``no-output'' option. Utool will still
\emph{compute} all solved forms in this case, it will simply not
\emph{output} them. This can be useful for runtime
measurements. Specify the option \verb?--no-output? or \verb?-n? on
the command line. In server mode, you get this effect if you simply
don't specify any output codec in the \verb?utool? element.

\item[display-statistics:] see the \verb?solvable? command
\end{description}





\subsubsection{Convert}

This command reads a USR and outputs it again. The point about this
operation is that the input and output codecs may be different. This
means that you can use it to convert USRs from one underspecification
formalism to another (to the extent that this is supported by theory).

\paragraph{Result.}
In command-line mode, Utool will output the USR using the specified
output codec. By default, it will write it to standard output, but you
can again redirect the output to a file. The command always returns an
exit code 0 on successful completion.

In server mode, Utool will send a reply of the following form:
\begin{verbatim}
<result usr='....' />
\end{verbatim}

The string in the \verb?usr? attribute is the converted USR. Remember
that you may need to resolve XML character entities that were used in
the attribute value strings.

\paragraph{Options.}
The \verb?convert? command can take the following options:
\begin{description}
\item[input-codec:] see \verb?solvable? 
\item[output-codec:] see \verb?solve? 
\item[output:] see \verb?solve?
\item[no-output:] see \verb?solve?
\item[display-statistics:] see \verb?solvable?
\end{description}



\subsubsection{Classify} \label{sec:op-classify}

The \verb?classify? command checks whether a dominance graph belongs
to certain particularly well-behaved classes. It currently
distinguishes the following classes:

\begin{itemize}
\item \emph{weakly normal}: A dominance graph is weakly normal
\cite{bodirsky-weakly-normal-constraints} if the tree edges form a
forest and all dominance edges go into roots.
\item \emph{normal}: A weakly normal dominance graph is normal
\cite{Althaus-J.Algo.} if all dominance edges also start in
(unlabelled) holes.
\item \emph{compact}: A weakly normal dominance graph is compact if
all fragments have depth zero or one, i.e.\ no node has both incoming
and outgoing tree edges.
\item \emph{compactifiable:} Many weakly normal graphs that are not
compact can nevertheless be made compact by removing internal nodes
and labelled leaves of fragments, and adding tree edges from the roots
to the holes. In particular, all normal graphs are compactifiable. If
a graph is compactifiable, it is guaranteed that there is a one-to-one
correspondence between the solved forms of the compactified graph and
the solved forms of the original graph.
\item \emph{hypernormally connected:} A normal graph is hypernormally
connected \cite{KolNieTha03,Koller04} if any pair of nodes is
connected by a simple hypernormal path, where a hypernormal path is an
undirected path that uses no two dominance edges that are adjacent to
the same hole. This graph class is a bit abstract, but immensely
useful because these graphs (a) have a lot of nice structural
properties, and (b) we believe that all graphs that are currently used
in underspecification are or should be hypernormally connected
\cite{FucKolNieTha04}. Because of (a), the translations of MRS and
Hole Semantics into dominance graphs only work for USRs that translate
into hypernormally connected graphs.
\item \emph{leaf-labelled:} A weakly normal graph is leaf-labelled
\cite{KolNieTha03} if every (unlabelled) hole has an outgoing
dominance edge. If a graph is both hypernormally connected and
leaf-labelled, each of its solved forms has a configuration.
\end{itemize}


\paragraph{Result.}
The classes to which a graph belongs are encoded as the bit-wise OR of
the following values:

\begin{center}
\begin{tabular}{l|l}
class & bit value \\ \hline
weakly normal & 1 \\
normal & 2 \\
compact & 4 \\
compactifiable & 8 \\
hypernormally connected & 16 \\
leaf-labelled & 32
\end{tabular}
\end{center}

The command-line tool will return this value as its exit code upon
successful completion.

The Utool Server will return a message of the following form:
\begin{verbatim}
<result code='63' weaklynormal='true' normal='true'
        compact='true' compactifiable='true'
        hypernormallyconnected='true' leaflabelled='true' />
\end{verbatim}

Here \verb?code? is the exit code described above, and the other
attributes are either \verb?true? or \verb?false?.


\paragraph{Options.}
The \verb?classify? command can take the following options:
\begin{description}
\item[input-codec:] see \verb?solvable? 
\item[display-statistics:] see \verb?solvable?
\end{description}


\subsubsection{Server}

The \verb?server? command starts a new Utool Server. By default, this
server listens to new connections on port 2802, but you can specify a
different port using the \verb?--port? option. This command is ignored
if Utool is already running in server mode; it can only be run from
the command line.

\paragraph{Result.} This command doesn't terminate by itself; you have
to shut down the server process by hand.

\paragraph{Options.} The \verb?server? command can take the following
options:

\begin{description}
\item[port:] By default, the server will listen on a socket on port
2802. You can specify a different port using the option
\verb?--port <number>? (or \verb?-p <number>?), where \verb?<number>?
is the port number you want.

\item[logging:] Using this option, you can make the server log
information about incoming commands and its responses. If you specify
the option \verb?--logging? (or \verb?-l?) by itself, the log messages
will be written to standard error. Alternatively, you can log the
messages into a file by specifying the filename:
\verb?--logging <filename>? or \verb?-l <filename>?.
\end{description}



\subsubsection{Display}


\todo{Write this once we have integrated Ubench into Utool.}

\paragraph{Result.} This command doesn't terminate by itself; you have
to shut down the server process by hand.

\paragraph{Options.} The \verb?server? command can take the following
options:

\begin{description}
\item[foo:]
\end{description}



\subsection{Pseudo-commands}

In addition to the six main commands, the command-line version of
Utool will accept a number of ``pseudo-commands'', which display help
information. If you call Utool with a pseudo-command, it executes the
pseudo-command and terminates immediately. You cannot specify both a
command and a pseudo-command at the same time.

There are the following pseudo-commands:

\begin{itemize}
\item \verb?help [command]?: If you specify a command, this will
display a brief help message for that command. Otherwise, this will
display an overview over the possible commands.
\item \verb?--version?: Displays the version of Utool.
\item \verb?--display-codecs? or \verb?-d?: Displays the installed
codecs.
\item \verb?--help-options?: Displays an overview over some frequently
used options.
\end{itemize}




\subsection{Options overview}

We conclude this section with an overview over all options.

\newcommand{\optiondesc}[4]{\item #1 \\ (Server mode: #2) \\
(applies to: #3) \\ \strut\\ #4}

\begin{itemize}
\optiondesc
{\texttt{--input-codec <codecname>} or \texttt{-I <codecname>}}
{\texttt{codec} attribute of the \texttt{usr} elements}
{\texttt{solvable}, \texttt{solve}, \texttt{classify}, \texttt{convert}}
{Specify the input codec.}

\optiondesc{\texttt{--input-codec-options <options>}}
{\texttt{codec-options} attribute of the \texttt{usr} elements}
{\texttt{solvable}, \texttt{solve}, \texttt{classify}, \texttt{convert}}
{If the selected input codec accepts options, use this option to
specify them.}

\optiondesc{\texttt{--output-codec <codecname>} or \texttt{-O <codecname>}}
{\texttt{output-codec} attribute of the \texttt{utool} element}
{\texttt{solve}, \texttt{convert}}
{Specify the output codec.}

\optiondesc{\texttt{--output-codec-options <options>}}
{\texttt{output-codec-options} attribute of the \texttt{utool} element}
{\texttt{solve}, \texttt{convert}}
{If the selected output codec accepts options, use this option to
specify them.}

\optiondesc{\texttt{--no-output} or \texttt{-n}}
{assumes this option if no output codec is specified}
{\texttt{solve}, \texttt{convert}}
{Compute the output, but don't display it (useful for runtime
measurements). If you specify this option, you don't need to specify
the output codec (and if you do, it is ignored). }

\optiondesc{\texttt{--output <filename>} or \texttt{-o <filename>}}
{not applicable: the server doesn't write to an output file}
{\texttt{solve}, \texttt{convert}}
{Write the output to the specified file, rather than to standard
output. If you use this option and don't specify an output codec
explicitly, Utool will try to guess the appropriate output codec from
the filename extension.}




\optiondesc{\texttt{--display-statistics} or \texttt{-s}}
{not applicable: the server reports statistics information anyway}
{\texttt{solvable}, \texttt{solve}, \texttt{classify}, \texttt{convert}}
{Display statistics information while executing the command, such as
information about the graph classification, chart size, and
runtimes. All statistics information is written to standard error.}


\optiondesc{\texttt{--equivalences <equivfile>} or
\texttt{-e <equivfile>}}
{specify an element of the form \texttt{<eliminate equations="..." />}
as a child of the \texttt{utool} element}
{\texttt{solvable}, \texttt{solve}}
{Run a redundancy elimination algorithm on the chart
\cite{koller06:_towar}. This is an 
advanced option that is documented \todo{somewhere -- where should
this go?}.}


\end{itemize}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "0"
%%% TeX-command-default: "LaTeX"
%%% End: 
