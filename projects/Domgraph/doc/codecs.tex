\section{Codecs}  \label{sec:codecs}

Utool is intended as a ``Swiss Army Knife'' for working with
underspecified representations, and one of our design goals was
therefore to make it compatible with as many current
underspecification formalisms as possible. This is not a trivial task,
as different formalisms typically differ in crucial details, and naive
translations from one formalism to another are typically incorrect for
pathological inputs.

As we have explained above, Utool internally works with labelled
dominance graphs and uses \emph{codecs} to translate between these
graphs and the actual USRs that the user sees. An \emph{input codec}
transforms a USR in a certain format into an equivalent labelled
dominance graph, and an \emph{output codec} transforms a labelled
dominance graph into a USR in a certain format. 

Some codecs are quite simple; for instance, the \verb?domcon-gxl?
codec simply deals with one particular concrete syntax for labelled
dominance graphs. However, there are also input codecs for MRS and
Hole Semantics that do quite a bit of work to compute correct
dominance graphs, and rely on nontrivial formal results; and there are
output codecs for reading the solutions as terms or translating them
into graph file formats that can be displayed using external viewers.

In addition, the Codec API is quite simple, and writing your own codec
doesn't require a deep knowledge of the rest of the Utool system. As
long as you observe certain rules about the labelled dominance graph
that your input codec computes for your own underspecification
formalism, the rest of the Utool system will simply cooperate with
your new codec. In fact, you don't even have to recompile Utool to
make your new codec available to it -- you can simply package your own
codec into a Jar file and add it to the classpath when running Utool.

Below, we will go through the input and output codecs in the current
Utool distribution one by one, explain the formal background and the
concrete syntax we assume, and discuss their limitations.



\subsection{The domcon-oz codecs}

The \verb?domcon-oz? codecs deal with representations of dominance
constraints \cite{clls2000} as lists of terms of the Oz programming
language. An example USR that these codecs can deal with looks as
follows:

\begin{verbatim}
[label(x f(x1)) label(y g(y1)) label(z a) dom(x1 z) dom(y1 z)]
\end{verbatim}

As you can see, USRs are lists of terms whose head symbols are either
\verb?label? or \verb?dom?. Each such term stands for an \emph{atom}
of a dominance constraint. The \emph{labelling atom}
\verb?label(x f(x1 ... xn))?  (where $n \geq 0$) expresses that the
node \verb?x? should have the label \verb?f? and its children in a
tree that satisfies the constraint should be the nodes \verb?x1? to
\verb?xn?, from left to right. The \emph{dominance atom}
\verb?dom(x y)? expresses that the node \verb?x? should be above the
node \verb?y? in a satisfying tree. In addition, the constraint
contains an implicit inequality atom $x \neq y$ for any two symbols
$x$ and $y$ that appear as the first argument of a \verb?label? term.

This format was first used in the old CHORUS demo (in 1999 or so),
which was written in Mozart Oz. As we know today, weakly normal
dominance constraints can be seen as dominance graphs quite directly
\cite{Koller04}. If we want to read a \verb?domcon-oz?  USR as a
weakly normal dominance graph, we can read the term
\verb?label(x f(x1 ... xn))? as expressing that the node \verb?x? in
the dominance graph has the label \verb?f? and the children \verb?x1?
to \verb?xn? over tree edges. The term \verb?dom(x y)? then expresses
that there is a dominance edge from \verb?x? to \verb?y?. 

The \verb?domcon-oz? input codec considers lines that start with a
percent symbol as comments and ignores them. Both the input and the
output codec will deal with arbitrary labelled dominance graphs, even
if they are not weakly normal. These codecs are associated with the
filename extension \verb?.clls?.



\subsection{The domgraph-gxl codecs}

The \verb?domgraph-gxl? codecs deal with representations of a labelled
dominance graph in the GXL graph representation language. GXL
(\url{http://www.gupro.de/GXL/}) is a XML-based standard language for
this purpose. A USR in this format looks as follows:

\begin{verbatim}
<gxl xmlns:xlink="http://www.w3.org/1999/xlink">
   <graph id="utool-graph" edgeids="true" hypergraph="false" edgemode="directed">
      <node id="x">
         <type xlink:href="root" />
         <attr name="label"><string>f</string></attr>
      </node>
      <edge from="x" to="x1" id="edge0">
        <type xlink:href="solid" />
      </edge>

      <node id="x1">
         <type xlink:href="hole" />
      </node>
      <edge from="x1" to="z" id="edge3">
        <type xlink:href="dominance" />
      </edge>

      <node id="z">
         <type xlink:href="leaf" />
         <attr name="label"><string>a</string></attr>
      </node>
   </graph>
</gxl>
\end{verbatim}

The USR specifies nodes (using \verb?node? elements), which can have
the type \verb?root? (a node with outgoing tree edges), \verb?hole? (a
node with incoming but no outgoing tree edges), or \verb?leaf? (a node
with not adjacent tree edges). Each node which is not a hole must have
an embedded \verb?attr? element which specifies its label. In
addition, the USR specifies edges, which can have the types
\verb?solid? or \verb?dominance?.

The \verb?domgraph-gxl? codecs are intended primarily as a portable exchange
format for labelled dominance graphs. Both the input and the output codec
will deal with arbitrary labelled dominance graphs, even if they are not
weakly normal. These codecs are associated with the filename extension
\verb?.dg.xml?.



\subsection{The MRS input codecs}

Utool supports two input codecs that deal with underspecified
representations based upon Minimal Recursion Semantics (MRS;
\citeNP{CopFliSag97}), the standard scope underspecification formalism
used in current HPSG grammars. The \verb|mrs-prolog| codec deals with
MRS expressions in a Prolog style term representation. Alternatively,
the \verb|mrs-xml| codec deals with MRS expressions based upon an
XML-style syntax. Both codecs are compatible with the concrete syntax
that is used in the LKB system \cite{Copestake:LKB-Book}.

Utool doesn't contain any MRS output codecs, because MRS makes some
specific assumptions about the underlying object language, and it is
not clear that a useful class of labelled dominance graphs can indeed
be correctly translated into MRS.

\paragraph{The mrs-prolog input codec.}

A concrete example of a Prolog style MRS expression looks as follows:

\begin{verbatim}
psoa(h1,e2,
  [ rel('prop-or-ques_m',h1,
        [ attrval('ARG0',e2),
          attrval('MARG',h3),
          attrval('PSV',u4),
          attrval('TPC',u5) ]),
    rel('_every_q',h6,
        [ attrval('ARG0',x7),
          attrval('RSTR',h9),
          attrval('BODY',h8) ]),
    rel('_dog_n_1',h10,
        [ attrval('ARG0',x7) ]),
    rel('_bark_v_1',h11,
        [ attrval('ARG0',e2),
          attrval('ARG1',x7) ]) ],
  hcons([ qeq(h3,h11), qeq(h9,h10) ]))
\end{verbatim}

Here, \verb|h1| is the top handle, and \verb|e2| an event
variable. Terms of the form 

\begin{verbatim} 
rel(L, H, [attrval(F, V), ...]) 
\end{verbatim} 

represent elementary predications, which pair a quoted string
\verb|L|, a handle \verb|H|, and a list of feature-value pairs.
Features are represented by (quoted) atoms, and values can be either
handles, object language individual or event variables,
``unspecified'' values (see below) and quoted strings. Finally, terms
of the form \verb|qeq(H1, H2)| represent handle constraints. Terms of
the form \verb|geq(H1, H2)| can also be used to express handle
constraints.

The codec makes the following assumptions:
\begin{itemize}
\item Handles start with a lowercase \verb|h| followed by a sequence
  of digits.
\item Individual variables start with a lowercase \verb|x| followed by
  a sequence of digits.
\item Event variables start with a lowercase \verb|e| followed by a
  sequence of digits.
\end{itemize}
The codec also accepts terms starting with lowercase \verb|u| or
\verb|i|, which correspond to values left unspecified by the
syntax-semantics interface of the grammar used to derive the MRS
expression. These terms are ignored by the input codec.

The codec implements an extended version of the translation of MRS
into normal dominance graphs defined by \citeN{mrs-dom}. During the
translation, the codec makes certain constraints that are implicit in
the MRS description explicit by adding dominance edges. Most
importantly, it adds a dominance edge from each quantifier to its
bound variables. We assume that quantifiers are elementary
predications which contain exactly the features \verb|ARG0|,
\verb|RSTR| and \verb|BODY|. An individual variable is treated as
bound if it occurs as the value of some other feature.\footnote{The
  features PSV and TPC are treated specially, and individual variables
  occurring as value of these features are ignored by the codec.}

In order to guarantee correctness of the translation, the codec makes
two important assumptions about the MRS structures is processes.
First, the \verb|qeq| (and \verb|geq|) constraints translate simply
into dominance edges. This is a conceptional simplification, which
however seems to be compatible with the way modern grammars make use
of \verb|qeq| constraints \cite{FucKolNieTha04}. Second, the
translation is restricted to MRS expressions whose graph satisfies
certain structural restrictions: The MRS must be a \emph{net}, or
equivalently, the resulting dominance graph must be normal,
hypernormally connected and leaf-labelled.

If the input MRS is not well-formed (see below) or not a net, the
codec reports an error. The error code is obtained by forming the
bitwise OR of 192 and the relevant bits in the following table. The
codec is able to report multiple errors at once, so e.g.\ if the input
MRS translates into a graph that is neither normal nor leaf-labelled,
the error code would be 201.

\begin{tabular}{lll}
code & symbolic name & meaning \\ \hline
1 &  \verb?NOT_NORMAL? & resulting graph is not normal \\
2 &  \verb?NOT_WEAKLY_NORMAL? & resulting graph is not weakly normal \\
4 &  \verb?NOT_HYPERNORMALLY_CONNECTED? & resulting graph is not hypernormally connected \\
8 &  \verb?NOT_LEAF_LABELLED? & resulting graph is not leaf-labelled \\
16 &  \verb?NOT_WELLFORMED? & the input MRS is not well-formed 
\end{tabular}

An MRS is not well-formed if it violates some (in the widest sense)
syntactic constraints, for instance, if it contains a variable
\verb|x| but no quantifier that binds \verb|x|. We should note that
this terminology departs from \cite{CopFliSag97}'s terminology: in
that paper, a well-formed MRS must additionally be solvable.


The input codec is associated with the filename extension \verb|.mrs.pl|.

\paragraph{The mrs-xml input codec.}

In addition to the Prolog style term representation, Utool also
supports an XML style syntax. Apart from the concrete syntax (XML as
opposed to Prolog terms), the two codecs are exactly the same. The
Prolog-style MRS expressions shown above is represented in XML as
follows:

\begin{verbatim}
<?xml version="1.0"?>
<mrs>
  <var vid="h1"/>
  <ep>
    <pred>prop-or-ques_m_rel</pred>
    <var vid="h1"/>
    <fvpair><rargname>ARG0</rargname><var vid="e2"/></fvpair>
    <fvpair><rargname>MARG</rargname><var vid="h3"/></fvpair>
    <fvpair><rargname>PSV</rargname><var vid="u4"/></fvpair>
    <fvpair><rargname>TPC</rargname><var vid="u5"/></fvpair>
  </ep>
  <ep>
    <pred>_every_q_rel</pred>
    <var vid="h6"/>
    <fvpair><rargname>ARG0</rargname><var vid="x7"/></fvpair>
    <fvpair><rargname>RSTR</rargname><var vid="h9"/></fvpair>
    <fvpair><rargname>BODY</rargname><var vid="h8"/></fvpair>
  </ep>
  <ep>
    <pred>_dog_n_1_rel</pred>
    <var vid="h10"/>
    <fvpair><rargname>ARG0</rargname><var vid="x7"/></fvpair>
  </ep>
  <ep>
    <pred>_bark_v_1_rel</pred>
    <var vid="h11"/>
    <fvpair><rargname>ARG0</rargname><var vid="e2"/></fvpair>
    <fvpair><rargname>ARG1</rargname><var vid="x7"/></fvpair>
  </ep>
  <hcons hreln="qeq">
    <hi><var vid="h3"/></hi>
    <lo><var vid="h11"/></lo>
  </hcons>
  <hcons hreln="qeq">
    <hi><var vid="h9"/></hi>
    <lo><var vid="h10"/></lo>
  </hcons>
</mrs>
\end{verbatim}

The input codec is associated with the filename extension \verb|.mrs.xml|.


\subsection{The holesem-comsem input codec}

The \verb?holesem-comsem? input codec can read USRs of the Hole
Semantics formalism. Hole Semantics \cite{Bos96} is a rather popular
underspecification formalism because it is conceptually very
accessible (underspecify formulas by allowing them to have holes which
can be plugged by other formulas). We assume the concrete syntax used
in the Prolog system that accompanies the Computational Semantics
textbook \cite{blackburn05:_repres_infer_natur_languag}; that is, it
should be possible to use all USRs generated by the book software with
this codec. USRs in this syntax are Prolog terms that look e.g.\ as
follows:

\begin{verbatim}
some(A, some(B, some(C, some(X, and(label(A), and(hole(B),
and(label(C), and(some(A, X, B), and(pred1(C,man,X), leq(C,B))))))))))
\end{verbatim}

Here \verb?A? and \verb?C? are labels, \verb?B? is a hole, and
\verb?X? is an object variable of the intended semantic
representation, which will be bound by an existential quantifier. All
four symbols are introduced by the outer \verb?some? terms. In
addition, the term \verb?some(A,X,B)? expresses that the formula under
the label \verb?A? is $\exists X. \verb?B?$, and the term
\verb?pred1(C,man,X)? expresses that the formula under the label
\verb?C? is $man(X)$. The term \verb?leq(C,B)? says that the label
\verb?C? must be below the hole \verb?B?.

The codec supports USRs built from the logical symbols \verb?hole?,
\verb?label?, \verb?some?, \verb?and?, \verb?or?, \verb?imp?,
\verb?not?, \verb?all?, \verb?leq?, \verb?que?, \verb?eq?,
\verb?pred1?, \verb?pred2?, and arbitrary non-logical symbols. It does
not support the symbols \verb?lam? and \verb?app? that are used in
intermediate representations during semantics construction by
Blackburn and Bos, as these symbols are beyond the scope of ordinary
Hole Semantics USRs (they don't relate holes and labels, but entire
Hole Semantics USRs).

This codec makes use of the theoretical result that Hole Semantics
USRs that are hypernormally connected and leaf-labelled can be
translated into equivalent labelled dominance graphs
\cite{KolNieTha03}. The translation itself is not that complicated,
but the correctness proof is not trivial. The codec checks whether the
resulting graph is normal, leaf-labelled, and hypernormally
connected. If it isn't, the codec reports this as a semantic error
with one of the following exit codes:

\begin{tabular}{lll}
code & symbolic name & meaning \\ \hline
193 &  \verb?ERROR_GRAPH_NOT_NORMAL? & resulting graph is not normal \\
194 &  \verb?ERROR_GRAPH_NOT_HNC? & resulting graph is not hypernormally
connected \\
195 &  \verb?ERROR_GRAPH_NOT_LEAF_LABELLED? & resulting graph is not
leaf-labelled \\
196 &  \verb?ERROR_MULTIPLE_PARENTS? & graph has a node with more than one
parent 
\end{tabular}

Although every normal, hypernormally connected, and leaf-labelled
dominance graph can in principle be translated back into an equivalent
Hole Semantics USR \cite{KolNieTha03}, there is no corresponding
output codec. This is because the concrete syntax imposes a number of
very inconvenient restrictions on the USRs that it can express. For
instance, all nodes that are not holes must have exactly one or two
children via tree edges, and all non-holes whose children are not
object-level variables must be labelled with a connective of predicate
logic. This has the consequence that only a tiny minority of all
labelled dominance graphs can actually be encoded given this syntax,
which made the encoding more difficult to implement and debug than we
felt it was worth.

The input codec is associated with the filename extension \verb?.hs.pl?.




\subsection{The domgraph-udraw and domgraph-dot output codecs}

As an alternative to the \verb|display| command, one can use utool to
convert underspecified representations into formats which can be
further processed by other graph viewers:

\begin{enumerate}
\item The \verb|domgraph-udraw| output-codec outputs a dominance graph
in a format that can be used to display the graph with the
uDraw(Graph) tool (formerly daVinci) from the University of Bremen
(\url{http://www.informatik.uni-bremen.de/uDrawGraph/en/index.html}); 
\item the \verb|domgraph-dot| codec outputs a dominance graph in the
``dot'' format supported by many graph drawing tools, such as 
\verb|graphviz| (\url{http://graphviz.org/}).
\end{enumerate}

We don't describe these output formats in detail here, but you can
write the output into a file and then load it from the respective
graph viewers. Note that these commands will only produce meaningful
output if you use them from the \verb|convert| command, rather than
the \verb|solve| command, as neither graph format supports the
representation of multiple graphs (i.e.\ the multiple solved forms
computed by \verb|solve|) at once.

As a further convenience, the \verb|domgraph-udraw| accepts the codec
option \verb|pipe|. If you use this codec option, you can directly
feed Utool's output to uDraw(Graph) via a pipe instead of writing the
graph to a file and then opening this file from uDraw(Graph), like so:

\begin{verbatim}
utool convert foo.clls -O domgraph-udraw --output-codec-options pipe \
   | uDrawGraph -pipe
\end{verbatim}

Both codecs are able to encode any labelled dominance graph, even if
it is not weakly normal, thus they never report any semantic
errors. The \verb|domgraph-udraw| codec is associated with the
filename extension \verb|.dg.udg|, and the \verb|domgraph-dot| codec
is associated with the extension \verb|.dg.dot|.



\subsection{The plugging output codecs}

The \verb?plugging-oz? and \verb?plugging-lkb? output codecs display a
dominance graph in solved form as a list of pairs (hole, root) that
specify the dominance edges in the solved form (in Hole Semantics
terminology, this is a \emph{plugging}). They differ only in the
concrete syntax:

\begin{itemize}
\item \verb?plugging-oz?: The output is an Oz list of lists of terms
  that looks as follows:
\begin{verbatim}
[[plug(xr2 y2) plug(xl2 x1) plug(xl1 y0) plug(xr1 y1)]
 [plug(xl1 y0) plug(xr1 x2) plug(xr2 y2) plug(xl2 y1)]]
\end{verbatim}
Each list consists of terms of the form \verb?plug(x y)? which encode
the dominance edges (here: from \verb?x? to \verb?y?) in the solved
form.
\item \verb?plugging-lkb?: The output is a complex Lisp list that
mimicks the output of the MRS solver in the LKB system. We don't
describe this concrete syntax here.
\end{itemize}

\verb?plugging-oz? is intended as a convenient output format if you
only want to see the dominance edges. On the other hand,
\verb?plugging-lkb? is practically relevant because it displays
pluggings in the format that the LKB workbench expects from its own
MRS solver. This means that Utool with the \verb?mrs-prolog? input
codec and the \verb?plugging-lkb? output codec can be used as a
drop-in replacement for the LKB's own MRS solver (see also
Section~\ref{sec:integration-lkb}).

These two codecs are only intended to be run on dominance graphs in
solved form. They will also accept any other dominance graph and will
then display its dominance edges, but this is less meaningful than
displaying the dominance edges in a solved form. The
\verb?plugging-oz? codec is associated with the filename extension
\verb?.plug.oz?, and the \verb?plugging-lkb? codec is associated with
the extension \verb?.lkbplug.lisp?.



\subsection{The term output codecs}

The \verb?term-oz? and \verb?term-prolog? output codecs can be used to
encode labelled dominance graphs in simple solved form, i.e.\ solved
forms which are trees and in which each hole has exactly one outgoing
dominance edge. They traverse these trees top-down and print the
ground term that corresponds to the tree structure. Their output looks
as follows:
\begin{itemize}
\item \verb?term-oz?: an Oz term of the form
\begin{verbatim}
f2(f1(a0 a1) a2)
f1(a0 f2(a1 a2))
\end{verbatim}
\item \verb?term-prolog?:  a Prolog term of the form
\begin{verbatim}
f2(f1(a0,a1),a2)
f1(a0,f2(a1,a2))
\end{verbatim}
\end{itemize}

The only difference between the two codecs is that the Prolog codec
separates arguments of a term by commas, whereas the Oz codec
separates them with whitespace. These two codecs are intended as
human-readable representations of solved forms.

Both codecs assume that the solved form they encode is simple and
leaf-labelled, and will report an error code of 193 if it
isn't. \verb?term-oz? is associated with the filename extension
\verb?.t.oz?, and \verb?term-prolog? with \verb?.t.pl?.





\subsection{The chain input codec}

The \verb?chain? input codec will generate the pure chain
\cite{Koller04} of a given length. A chain is a zig-zag graph
consisting of upper and lower fragments that are connected by
dominance edges; the pure chain of length 3 is shown in
Fig.~\ref{fig:chain3}. Chains appear frequently as parts of
linguistically motivated USRs, and are therefore a nice basis for
benchmarking (e.g.\ in \cite{bodirsky-weakly-normal-constraints}).

The ``underspecified descriptions'' that this codec expects in server
mode are simply string representations of numbers (such as the string
\verb?3?). The codec will then generate the pure chain of this
length. When used with the command-line version of Utool, \verb?chain?
behaves differently than all other codecs discussed so far in that it
doesn't interpret its argument as a filename, but again directly as
the chain length. This means that you can use a Utool call as follows:

\begin{verbatim}
$ utool convert -I chain 3 -O domcon-oz
\end{verbatim}
%$

The codec will report a parsing error (code 192) if the chain length
specification isn't a number, and a semantic error with code 193 if
the number isn't positive. Because \verb?chain? doesn't read its USRs
from files, it is not associated with any filename extension.






\subsection{Writing your own codecs}

Although Utool comes with a collection of codecs that cover many
existing popular underspecification formalisms, there are some
formalisms we don't support (yet), and we can expect that other
formalisms will be developed in the future. To this end, it may be
helpful for you to write your own codec. You can do this -- without
even touching the original Utool source code -- as follows.

\begin{enumerate}
\item \emph{Derive from base classes.} A codec is a class that is
derived from one of the abstract base classes \verb?InputCodec?,
\verb?GraphOutputCodec?, or \verb?PluggingOutputCodec?, all of which
are in the package
\verb?de.saar.chorus.domgraph.codec?.\footnote{Notice that we will
likely deprecate \texttt{PluggingOutputCodec} in the near future, so
we recommend that you derive output codecs from
\texttt{GraphOutputCodec}.}  Your own codec can be in any package you
like. You never need to create objects of your codec class; Utool
creates objects of your class as needed.

\item \emph{Implement methods.} Your codec class has the task of
writing a representation of a labelled dominance graph to a Java
\verb?Writer?  (if it is an output codec) or of reading such a
representation from a Java \verb?Reader? and initialising a labelled
dominance graph (if it is an input codec). In order to do this, you
must implement certain abstract methods that depend on the respective
base class. This is documented in more detail in the API documentation
of the codec base classes on the website, which is also distributed
with the Utool package.

\item \emph{Reporting errors.} Your (input) codec can report a parsing
error by throwing an exception of type
\url{de.saar.chorus.domgraph.codec.ParserException}. Utool will
generally report an error code of 192 in this case. Both input and
output codecs can also report semantic errors by throwing a
\url{de.saar.chorus.domgraph.codec.MalformedDomgraphException}. You
can (and should) pass a local error code $N$ between 1 and 31,
inclusively, in this case. Utool will then report an error code of
$192 + N$ for input codecs and $224 + N$ for output codecs. You can
also encapsulate detailed error messages and original exceptions in
both types of exceptions.

\item \emph{Constructors.} Your class must have either a public
constructor that takes no arguments, or a public constructor that
takes a single argument of type \verb?String?. If it defines the
second type of constructor, Utool will pass the codec options string
to your constructor if any were specified on the command line or in
the XML command. If no codec options were specified, it will pass the
value \verb?null?. Utool will always call the \verb?String?
constructor if it exists, and fall back to the argumentless
constructor if it doesn't.

\item \emph{Codec identification methods.} Your codec class is
expected to implement the public static methods \verb?getName()?  and
\verb?getExtension()?, both with return type \verb?String?.  These
methods should return the codec name and the filename extension that
you want to associate with your codec. \verb?getName? must generally
return a non-null value.

\item \emph{Making Utool aware of your codec.}  The final step of the
story is to make Utool aware of your new codec. This is handled by
creating a file
\url{de/saar/chorus/domgraph/codec/codecclasses.properties} somewhere
in your classpath. In this file, you list the fully qualified
classname(s) of your new codec(s), one per line. Utool will then
automatically read this file and load your codecs.

For instance, let's say that you have implemented and compiled a codec
class \url{foo.bar.MyCodec}. You would then create a
\url{codecclasses.properties} file that contains just one line that
reads ``\url{foo.bar.MyCodec}'', and start a MyCodec-enhanced version
of Utool as follows:


\begin{verbatim}
$ jar cf mycodec.jar foo/bar/MyCodec.class \
    de/saar/chorus/domgraph/codec/codecclasses.properties
$ java -cp Utool.jar:mycodec.jar de.saar.chorus.domgraph.utool.Utool -d
\end{verbatim}
%$

This will display your new codec along with the standard Utool ones.
\end{enumerate}






%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "0"
%%% TeX-command-default: "LaTeX"
%%% End: 
