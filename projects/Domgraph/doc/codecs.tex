\section{Codecs}  \label{sec:codecs}

\todo{document exit codes for all codecs:
\begin{itemize}
\item plugging codecs: 223 = ERROR\_NULL\_PLUGGING
\item chain: 193 = chain length $< 1$
\item term: 193 = not simple solved form
\end{itemize}
}

Utool is intended as a ``Swiss Army Knife'' for working with
underspecified representations, and one of our design goals was
therefore to make it compatible with as many current
underspecification formalisms as possible. This is not a trivial task,
as different formalisms typically differ in crucial details, and naive
translations from one formalism to another are typically incorrect for
pathological inputs.

As we have explained above, Utool internally works with labelled
dominance graphs and uses \emph{codecs} to translate between these
graphs and the actual USRs that the user sees. An \emph{input codec}
transforms a USR in a certain format into an equivalent labelled
dominance graph, and an \emph{output codec} transforms a labelled
dominance graph into a USR in a certain format. 

Some codecs are quite simple; for instance, the \verb?domcon-gxl?
codec simply deals with one particular concrete syntax for labelled
dominance graphs. However, there are also input codecs for MRS and
Hole Semantics that do quite a bit of work to compute correct
dominance graphs, and rely on nontrivial formal results; and there are
output codecs for reading the solutions as terms or translating them
into graph file formats that can be displayed using external viewers.

In addition, the Codec API is quite simple, and writing your own codec
doesn't require a deep knowledge of the rest of the Utool system. As
long as you observe certain rules about the labelled dominance graph
that your input codec computes for your own underspecification
formalism, the rest of the Utool system will simply cooperate with
your new codec. In fact, you don't even have to recompile Utool to
make your new codec available to it -- you can simply package your own
codec into a Jar file and add it to the classpath when running Utool.

Below, we will go through the input and output codecs in the current
Utool distribution one by one, explain the formal background and the
concrete syntax we assume, and discuss their limitations.



\subsection{The domcon-oz codecs}

The \verb?domcon-oz? codecs deal with representations of dominance
constraints \cite{clls2000} as lists of terms of the Oz programming
language. An example USR that these codecs can deal with looks as
follows:

\begin{verbatim}
[label(x f(x1)) label(y g(y1)) label(z a) dom(x1 z) dom(y1 z)]
\end{verbatim}

As you can see, USRs are lists of terms whose head symbols are either
\verb?label? or \verb?dom?. Each such term stands for an \emph{atom}
of a dominance constraint. The \emph{labelling atom}
\verb?label(x f(x1 ... xn))?  (where $n \geq 0$) expresses that the
node \verb?x? should have the label \verb?f? and its children in a
tree that satisfies the constraint should be the nodes \verb?x1? to
\verb?xn?, from left to right. The \emph{dominance atom}
\verb?dom(x y)? expresses that the node \verb?x? should be above the
node \verb?y? in a satisfying tree. In addition, the constraint
contains an implicit inequality atom $x \neq y$ for any two symbols
$x$ and $y$ that appear as the first argument of a \verb?label? term.

This format was first used in the old CHORUS demo (in 1999 or so),
which was written in Mozart Oz. As we know today, weakly normal
dominance constraints can be seen as dominance graphs quite directly
\cite{Koller04}. If we want to read a \verb?domcon-oz?  USR as a
weakly normal dominance graph, we can read the term
\verb?label(x f(x1 ... xn))? as expressing that the node \verb?x? in
the dominance graph has the label \verb?f? and the children \verb?x1?
to \verb?xn? over tree edges. The term \verb?dom(x y)? then expresses
that there is a dominance edge from \verb?x? to \verb?y?. 

The \verb?domcon-oz? input codec considers lines that start with a
percent symbol as comments and ignores them. Both the input and the
output codec will deal with arbitrary labelled dominance graphs, even
if they are not weakly normal. These codecs are associated with the
filename extension \verb?.clls?.



\subsection{The domgraph-gxl codecs}

The \verb?domgraph-gxl? codecs deal with representations of a labelled
dominance graph in the GXL graph representation language. GXL
(\url{http://www.gupro.de/GXL/}) is a XML-based standard language for
this purpose. A USR in this format looks as follows:

\begin{verbatim}
<gxl xmlns:xlink="http://www.w3.org/1999/xlink">
   <graph id="utool-graph" edgeids="true" hypergraph="false" edgemode="directed">
      <node id="x">
         <type xlink:href="root" />
         <attr name="label"><string>f</string></attr>
      </node>
      <edge from="x" to="x1" id="edge0">
        <type xlink:href="solid" />
      </edge>

      <node id="x1">
         <type xlink:href="hole" />
      </node>
      <edge from="x1" to="z" id="edge3">
        <type xlink:href="dominance" />
      </edge>

      <node id="z">
         <type xlink:href="leaf" />
         <attr name="label"><string>a</string></attr>
      </node>
   </graph>
</gxl>
\end{verbatim}

The USR specifies nodes (using \verb?node? elements), which can have
the type \verb?root? (a node with outgoing tree edges), \verb?hole? (a
node with incoming but no outgoing tree edges), or \verb?leaf? (a node
with not adjacent tree edges). Each node which is not a hole must have
an embedded \verb?attr? element which specifies its label. In
addition, the USR specifies edges, which can have the types
\verb?solid? or \verb?dominance?.

The \verb?domgraph-gxl? codecs are intended primarily as a portable exchange
format for labelled dominance graphs. Both the input and the output codec
will deal with arbitrary labelled dominance graphs, even if they are not
weakly normal. These codecs are associated with the filename extension
\verb?.dg.xml?.



\subsection{MRS input codecs}

Utool supports two input codecs that deal with underspecified representations
based upon Minimal Recursion Semantics (MRS; \citeNP{CopFliSag97}), the
standard scope underspecification formalism used in current HPSG grammars.
The \verb|mrs-prolog| codec deals with MRS expressions in a Prolog style term
representation. Alternatively, the \verb|mrs-xml| codec can be used for MRS
expressions based upon an XML-style syntax. Both codecs are compatible with
the LKB system \cite{Copestake:LKB-Book}.

At the moment, utool does not support output codecs to display fully specified (scope resolved) MRS expressions.

\paragraph{The mrs-prolog input codec.}

A concrete example of a Prolog style MRS expression looks as follows:

\begin{verbatim}
psoa(h1,e2,
  [ rel('prop-or-ques_m',h1,
        [ attrval('ARG0',e2),
          attrval('MARG',h3),
          attrval('PSV',u4),
          attrval('TPC',u5) ]),
    rel('_every_q',h6,
        [ attrval('ARG0',x7),
          attrval('RSTR',h9),
          attrval('BODY',h8) ]),
    rel('_dog_n_1',h10,
        [ attrval('ARG0',x7) ]),
    rel('_bark_v_1',h11,
        [ attrval('ARG0',e2),
          attrval('ARG1',x7) ]) ],
  hcons([ qeq(h3,h11), qeq(h9,h10) ]))
\end{verbatim}

Here, \verb|h1| is the top handle, and \verb|e2| an event variable. Terms of
the form \begin{verbatim} rel(L, H, [attrval(F, V), ...]) \end{verbatim}
represent elementary predications, which pair a quoted string \verb|L|, a
handle \verb|H|, and a list of feature-value pairs. Features are represented
by quoted strings, and values can be either handles, object language
individual or event variables, ``unspecified'' values (see below) and quoted
strings. Finally, terms of the form \verb|qeq(H, H')| represent handle
constraints. Terms of the form \verb|geq(H, H')| can also be used to express
handle constraints.

The codec makes the following assumptions:
\begin{itemize}
\item Handles start with a lowercase \verb|h| followed by a sequence
  of digits.
\item Individual variables start with a lowercase \verb|x| followed by
  a sequence of digits.
\item Event variables start with a lowercase \verb|e| followed by a
  sequence of digits.
\end{itemize}
The codec also accepts terms starting with lowercase \verb|u| or
\verb|i|, which correspond to values left unspecified by the
syntax-semantics interface of the grammar used to derive the MRS
expression.

The codec implements a slightly extended version of the translation of MRS
into normal dominance graphs defined by \citeN{mrs-dom}. The translation
itself is relatively straightforward, but the correctness proof is quite
complicated and requires that MRS expressions satisfy certain structural
restrictions (see also below).

For the translation to be correct, some implicit constraints built into the
MRS formalisms must be made explicit in the corresponding dominance graph.
Most importantly, the translation must add additional dominance edges to the
dominance graph to model variable binding. To this end, the codec must find
out which elementary predications correspond to quantifiers, and which
individual variables occur bound: The codec assumes that elementary
predications which contain exactly the features \verb|ARG0|, \verb|RSTR| and
\verb|BODY| are quantifies. If an individual variable occurs as value of some
other feature, it it treated as bound.\footnote{The features PSV and TPC are
treated specially, and individual variables occurring as value of these
features are ignored by the codec.}

Note that the translation is restricted in two ways: First, the \verb|qeq|
constraints are modelled as more general dominance constraints. This is a
conceptional simplification, which however is compatible with the way modern
grammars make use of \verb|qeq| constraints \cite{mrs-eval}. Second, the
translation is restricted to MRS expressions whose graph satisfies certain
structural restrictions. The codec checks for these restrictions: The MRS
must be a \emph{net}, which is equivalent to the corresponding dominance
graph to be normal, hypernormally connected and leaf-labelled. The codec
reports an error is the MRS cannot be translated into a dominance graph that
satisfies these restrictions:

\begin{tabular}{lll}
code & symbolic name & meaning \\ \hline
XXX &  \verb?NOT_NORMAL? & resulting graph is not normal \\
XXX &  \verb?NOT_WEAKLY_NORMAL? & resulting graph is not weakly normal \\
XXX &  \verb?NOT_HYPERNORMALLY_CONNECTED? & resulting graph is not hypernormally connected \\
XXX &  \verb?NOT_LEAF_LABELLED? & resulting graph is not leaf-labelled \\
XXX &  \verb?NOT_WELLFORMED? & the input MRS is not wellformed
\end{tabular}

The input codec is associated with the filename extension \verb|.mrs.pl|.

\paragraph{The mrs-xml input codec.}

In addition to the Prolog style term representation, utool also supports an XML style syntax. The Prolog style MRS expressions shown above is represented in XML as follows:

\begin{verbatim}
<?xml version="1.0"?>
<mrs>
  <var vid="h1"/>
  <ep>
    <pred>prop-or-ques_m_rel</pred>
    <var vid="h1"/>
    <fvpair><rargname>ARG0</rargname><var vid="e2"/></fvpair>
    <fvpair><rargname>MARG</rargname><var vid="h3"/></fvpair>
    <fvpair><rargname>PSV</rargname><var vid="u4"/></fvpair>
    <fvpair><rargname>TPC</rargname><var vid="u5"/></fvpair>
  </ep>
  <ep>
    <pred>_every_q_rel</pred>
    <var vid="h6"/>
    <fvpair><rargname>ARG0</rargname><var vid="x7"/></fvpair>
    <fvpair><rargname>RSTR</rargname><var vid="h9"/></fvpair>
    <fvpair><rargname>BODY</rargname><var vid="h8"/></fvpair>
  </ep>
  <ep>
    <pred>_dog_n_1_rel</pred>
    <var vid="h10"/>
    <fvpair><rargname>ARG0</rargname><var vid="x7"/></fvpair>
  </ep>
  <ep>
    <pred>_bark_v_1_rel</pred>
    <var vid="h11"/>
    <fvpair><rargname>ARG0</rargname><var vid="e2"/></fvpair>
    <fvpair><rargname>ARG1</rargname><var vid="x7"/></fvpair>
  </ep>
  <hcons hreln="qeq">
    <hi><var vid="h3"/></hi>
    <lo><var vid="h11"/></lo>
  </hcons>
  <hcons hreln="qeq">
    <hi><var vid="h9"/></hi>
    <lo><var vid="h10"/></lo>
  </hcons>
</mrs>
\end{verbatim}

The input codec is associated with the filename extension \verb|.mrs.xml|.


\subsection{The holesem-comsem input codec}

The \verb?holesem-comsem? input codec can read USRs of the Hole
Semantics formalism. Hole Semantics \cite{Bos96} is a rather popular
underspecification formalism because it is conceptually very
accessible (underspecify formulas by allowing them to have holes which
can be plugged by other formulas). We assume the concrete syntax used
in the Prolog system that accompanies the Computational Semantics
textbook \cite{blackburn05:_repres_infer_natur_languag}; that is, it
should be possible to use all USRs generated by the book software with
this codec. USRs in this syntax are Prolog terms that look e.g.\ as
follows:

\begin{verbatim}
some(A, some(B, some(C, some(X, and(label(A), and(hole(B),
and(label(C), and(some(A, X, B), and(pred1(C,man,X), leq(C,B))))))))))
\end{verbatim}

Here \verb?A? and \verb?C? are labels, \verb?B? is a hole, and
\verb?X? is an object variable of the intended semantic
representation, which will be bound by an existential quantifier. All
four symbols are introduced by the outer \verb?some? terms. In
addition, the term \verb?some(A,X,B)? expresses that the formula under
the label \verb?A? is $\exists X. \verb?B?$, and the term
\verb?pred1(C,man,X)? expresses that the formula under the label
\verb?C? is $man(X)$. The term \verb?leq(C,B)? says that the label
\verb?C? must be below the hole \verb?B?.

The codec supports USRs built from the logical symbols \verb?hole?,
\verb?label?, \verb?some?, \verb?and?, \verb?or?, \verb?imp?,
\verb?not?, \verb?all?, \verb?leq?, \verb?que?, \verb?eq?,
\verb?pred1?, \verb?pred2?, and arbitrary non-logical symbols. It does
not support the symbols \verb?lam? and \verb?app? that are used in
intermediate representations during semantics construction by
Blackburn and Bos, as these symbols are beyond the scope of ordinary
Hole Semantics USRs (they don't relate holes and labels, but entire
Hole Semantics USRs).

This codec makes use of the theoretical result that Hole Semantics
USRs that are hypernormally connected and leaf-labelled can be
translated into equivalent labelled dominance graphs
\cite{KolNieTha03}. The translation itself is not that complicated,
but the correctness proof is not trivial. The codec checks whether the
resulting graph is normal, leaf-labelled, and hypernormally
connected. If it isn't, the codec reports this as a semantic error
with one of the following exit codes:

\begin{tabular}{lll}
code & symbolic name & meaning \\ \hline
193 &  \verb?ERROR_GRAPH_NOT_NORMAL? & resulting graph is not normal \\
194 &  \verb?ERROR_GRAPH_NOT_HNC? & resulting graph is not hypernormally
connected \\
195 &  \verb?ERROR_GRAPH_NOT_LEAF_LABELLED? & resulting graph is not
leaf-labelled \\
196 &  \verb?ERROR_MULTIPLE_PARENTS? & graph has a node with more than one
parent 
\end{tabular}

Although every normal, hypernormally connected, and leaf-labelled
dominance graph can in principle be translated back into an equivalent
Hole Semantics USR \cite{KolNieTha03}, there is no corresponding
output codec. This is because the concrete syntax imposes a number of
very inconvenient restrictions on the USRs that it can express. For
instance, all nodes that are not holes must have exactly one or two
children via tree edges, and all non-holes whose children are not
object-level variables must be labelled with a connective of predicate
logic. This has the consequence that only a tiny minority of all
labelled dominance graphs can actually be encoded given this syntax,
which made the encoding more difficult to implement and debug than we
felt it was worth.

The input codec is associated with the filename extension \verb?.hs.pl?.




\subsection{The domgraph-udraw and domgraph-dot output codecs}

As an alternative to the \verb|display| command, one can use utool to 
convert underspecified representations into formats which can be further processed by other graph viewers: The \verb|domgraph-udraw| output-codec outputs a dominance graph in a format that can be used to display the graph with \verb|uDraw(Graph)|, and the \verb|domgraph-dot| display dominance graphs in the .dot-format, which for instance can be displayed using \verb|graphviz|. 

The \verb|domgraph-udraw| accepts the codec opttion \verb|pipe|. This option must be specified if the output graph is to be send to uDrawGraph by a pipe, because the formats differ slightly depending on whether uDrawGraph reads its input from a file or from standard input/pipe. For instance:
\begin{verbatim}
java -jar Utool.jar convert -O domgraph-udraw --output-codec-options pipe foo.clls | uDrawGraph -pipe
\end{verbatim}




\subsection{The plugging output codecs}

The \verb?plugging-oz? and \verb?plugging-lkb? output codecs display a
dominance graph in solved form as a list of pairs (hole, root) that
specify the dominance edges in the solved form (in Hole Semantics
terminology, this is a \emph{plugging}). They differ only in the
concrete syntax:

\begin{itemize}
\item \verb?plugging-oz?: The output is an Oz list of lists of terms
  that looks as follows:
\begin{verbatim}
[[plug(xr2 y2) plug(xl2 x1) plug(xl1 y0) plug(xr1 y1)]
 [plug(xl1 y0) plug(xr1 x2) plug(xr2 y2) plug(xl2 y1)]]
\end{verbatim}
Each list consists of terms of the form \verb?plug(x y)? which encode
the dominance edges (here: from \verb?x? to \verb?y?) in the solved
form.
\item \verb?plugging-lkb?: This output codec is intended to be used for the integration of utool into the LKB system. \todo{see somewhere else}

\end{itemize}

\verb?plugging-oz? is intended as a convenient output format if you
only want to see the dominance edges. On the other hand,
\verb?plugging-lkb? is practically relevant because it displays
pluggings in the format that the LKB workbench expects from its own
MRS solver. This means that Utool with the \verb?mrs-prolog? input
codec and the \verb?plugging-lkb? output codec can be used as a
drop-in replacement for the LKB's own MRS solver (see also
Section~\ref{sec:integration-lkb}).

These two codecs are only intended to be run on dominance graphs in
solved form. They will also accept any other dominance graph and will
then display its dominance edges, but this is less meaningful than
displaying the dominance edges in a solved form. The
\verb?plugging-oz? codec is associated with the filename extension
\verb?.plug.oz?, and the \verb?plugging-lkb? codec is associated with
the extension \verb?.lkbplug.lisp?.



\subsection{The term output codecs}

The \verb?term-oz? and \verb?term-prolog? output codecs can be used to
encode labelled dominance graphs in simple solved form, i.e.\ trees in
which each hole has exactly one outgoing dominance edge. They traverse
these trees top-down and print the ground term that corresponds to the
tree structure. Their output looks as follows:
\begin{itemize}
\item \verb?term-oz?: an Oz term of the form
\begin{verbatim}
f2(f1(a0 a1) a2)
f1(a0 f2(a1 a2))
\end{verbatim}
\item \verb?term-prolog?:  a Prolog term of the form
\begin{verbatim}
f2(f1(a0,a1),a2)
f1(a0,f2(a1,a2))
\end{verbatim}
\end{itemize}

The only difference between the two codecs is that the Prolog codec
separates arguments of a term by commas, whereas the Oz codec
separates them with whitespace. These two codecs are intended as
human-readable representations of solved forms.

Both codecs assume that the solved form they encode is simple and
leaf-labelled, and will throw a \verb?MalformedDomgraphException? if
it isn't.

\verb?term-oz? is associated with the filename extension \verb?.t.oz?, and
\verb?term-prolog? with \verb?.t.pl?.





\subsection{The chain input codec}

The \verb?chain? input codec will generate the pure chain
\cite{Koller04} of a given length. A chain is a zig-zag graph
consisting of upper and lower fragments that are connected by
dominance edges; the pure chain of length 3 is shown in
Fig.~\ref{fig:chain3}. Chains appear frequently as parts of
linguistically motivated USRs, and are therefore a nice basis for
benchmarking (e.g.\ in \cite{bodirsky-weakly-normal-constraints}).

The ``USRs'' that can be processed by this codec are simply string
representations of numbers (such as the string \verb?3?). The codec
will then generate the pure chain of this length. When used with the
command-line version of Utool, \verb?chain? behaves differently than
all other codecs discussed so far in that it doesn't interpret its
argument as a filename, but again directly as the chain length. This
means that you can use a Utool call as follows:

\begin{verbatim}
$ java -jar Utool.jar convert -I chain 3 -O domcon-oz
\end{verbatim}
%$

The codec will throw a \verb?ParserException? if the length string
isn't a number, and a \verb?MalformedDomgraphException? if the number
isn't positive. Because \verb?chain? doesn't read its USRs from files,
it is not associated with any filename extension.






\subsection{Writing your own codecs}

Although Utool comes with a collection of codecs that cover most
existing popular underspecification formalisms, there are some
formalisms we don't support (yet), and we can expect that other
formalisms will be developed in the future. To this end, it may be
helpful for you to write your own codec.

A codec is a class that is derived from one of the abstract base
classes \verb?InputCodec?, \verb?GraphOutputCodec?, or
\verb?PluggingOutputCodec?, all of which are in the package
\verb?de.saar.chorus.domgraph.codec?. Your own codec can be in any
package you like. You never need to create objects of your codec
class; Utool creates objects of your class as needed.

Your codec class has the task of writing a representation of a
dominance graph to a Java \verb?Writer? (if it is an output codec) or
of reading such a representation from a Java \verb?Reader? and
initialising a labelled dominance graph (if it is an input codec). In
order to do this, you must implement certain abstract methods that
depend on the respective base class. This is documented in more detail
in the API documentation of the codec base classes on the website,
which is also distributed with the Utool package.

Your class must also have either a public constructor that takes no
arguments, or a public constructor that takes a single argument of
type \verb?String?. If it defines the second type of constructor,
Utool will pass the codec options string to your constructor if any
were specified on the command line or in the XML command. If no codec
options were specified, it will pass the value \verb?null?. Utool will
always call the \verb?String? constructor if it exists, and fall back
to the argumentless constructor if it doesn't.

In addition, your codec class is expected to implement public static
methods \verb?getName()? and \verb?getExtension()?, both with return
type \verb?String?.  These methods should return the codec name and
the filename extension that you want to associate with your
codec. \verb?getName? must generally return a non-null value.

The final step of the story is to make Utool aware of your new
codec. This is handled by creating a file
\url{de/saar/chorus/domgraph/codec/codecclasses.properties} somewhere
in your classpath. In this file, you list the fully qualified
classname(s) of your new codec(s), one per line. Utool will then
automatically read this file and load your codecs.

For instance, let's say that you have implemented and compiled a codec
class \url{foo.bar.MyCodec}. You would then create a
\url{codecclasses.properties} file that contains just one line that
reads ``\url{foo.bar.MyCodec}'', and start a MyCodec-enhanced version
of Utool as follows:


\begin{verbatim}
$ jar cf mycodec.jar foo/bar/MyCodec.class \
    de/saar/chorus/domgraph/codec/codecclasses.properties
$ java -cp Utool.jar:mycodec.jar de.saar.chorus.domgraph.utool.Utool -d
\end{verbatim}
%$

This will display your new codec along with the standard Utool ones.



\todo{MalformedDomgraphException vs ParserException}





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "0"
%%% TeX-command-default: "LaTeX"
%%% End: 
