/*
 * The hole semantics syntax is idiosyncratic in a number of ways which
 * make this codec a little messy.
 *
 * - The symbols "some" and "and" are used both for meta-level variable
 *   introduction and conjunction and as the heads of labelling atoms.
 *   We distinguish between the two types of usage by increasing the
 *   lookahead of the rules for the meta-level usage.
 *
 * - Prolog variables are used both as meta-level and as object-level
 *   variables. The latter are intended to introduce anonymous nodes
 *   labelled with this variable. We deal with this by keeping track
 *   of the meta-level variables (declared as "hole" or "label"),
 *   and introducing anonymous nodes by need.
 *
 * After the initial graph is constructed from the input file,
 * we postprocess it in the following ways:
 *
 * - If there is a single unlabelled top node (as is standard in
 *   Hole Semantics), we introduce a new fake node with a null label
 *   above it. This fake node must be ignored by output codecs.
 *
 * - Dominance edges pointing to non-roots have their targets moved
 *   up so they point to the respective roots.
 *
 * If anything goes wrong during these operations, or if the final
 * graph is not normal, the codec raises a MalformedDomgraphException.
 *
 */




options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
}

PARSER_BEGIN(HolesemComsemInputCodec)

package de.saar.chorus.domgraph.codec.holesem;

import java.io.*;
import java.util.*;

import de.saar.chorus.domgraph.graph.*;
import de.saar.chorus.domgraph.codec.*;
import org._3pq.jgrapht.Edge;



public class HolesemComsemInputCodec extends InputCodec {
    private DomGraph graph;
    private NodeLabels labels;
  private List<String> varlist;
  private int nextGensymIndex;

    public HolesemComsemInputCodec() {
	this((Reader) null);

	setName("holesem-comsem");
	setExtension(".hs.pl");
	varlist = new ArrayList<String>();
    }
    
    public void decode(Reader inputStream, DomGraph graph, NodeLabels labels)
	throws IOException, ParserException, MalformedDomgraphException {
        List<String> topNodes = new ArrayList<String>();

	this.graph = graph;
	this.labels = labels;

	graph.clear();
	labels.clear();
	varlist.clear();

	nextGensymIndex = 1;

	try {
	    ReInit(inputStream);
	    Input();
	} catch(ParseException e) {
	    throw new ParserException();
	}

/** I don't see why we need to ensure there is a top fragment. - ak 02/06
	// put a label above the top hole if necessary
	for( String node : graph.getAllNodes() ) {
	  if( graph.indeg(node) == 0 ) {
	    topNodes.add(node);
	  }
	}

	switch(topNodes.size()) {
	case 0:
	  // NOP -- the graph has a cycle, and we will detect this later
	  break;

	case 1:
	  // there is a single top node; if it is unlabelled, add a fake root
	  String topnode = topNodes.iterator().next();

	  if( graph.getData(topnode).getType() == NodeType.UNLABELLED ) {
	    graph.addNode("__hs_topnode__", new NodeData(NodeType.LABELLED));
	    labels.addLabel("__hs_topnode__", null);
	    graph.addEdge("__hs_topnode__", topnode,
			  new EdgeData(EdgeType.TREE));
	  }

	  break;

	default:
	  // more than one top node => can't fix this with a fake root
	  throw new MalformedDomgraphException();
	}
	**/


	// move dom edges up to roots
	List<Edge> allEdges = new ArrayList<Edge>();
	allEdges.addAll(graph.getAllEdges());

	for( int i = 0; i < allEdges.size(); i++ ) {
	  Edge edge = allEdges.get(i);

	  if( graph.getData(edge).getType() == EdgeType.DOMINANCE ) {
	    if( !graph.isRoot((String) edge.getTarget()) ) {
	      EdgeData data = graph.getData(edge);
	      String src = (String) edge.getSource();
	      String rootOfTarget = (String) edge.getTarget();

	      while( !graph.isRoot(rootOfTarget) ) {
		List<String> parents = graph.getParents(rootOfTarget, EdgeType.TREE);
		if( parents.size() > 1 ) {
		  throw new MalformedDomgraphException();
		} else {
		  rootOfTarget = parents.get(0);
		}
	      }

	      // System.err.println("Move target of " + edge + " to " + rootOfTarget);
	      graph.remove(edge);
	      graph.addEdge(src, rootOfTarget, data);
	    }
	  }
	}
	
	CodecTools.graphLabelsConsistencyAssertion(graph, labels);

	// at this point, the graph must be normal; otherwise, the
	// encoding was not applicable in the first place.
	if( !graph.isNormal() ) {
	  throw new MalformedDomgraphException();
	}
    }


    private String stripquotes(String label) {
	if( label.startsWith("\'") ) {
	    // strip off first and last character
	    return label.substring(1, label.length()-1);
	} else {
	    return label;
	}
    }


  /*
   * Management of holes, labels, and anonymous nodes.
   *
   * One complication in the holesem syntax is that a Prolog variable
   * can be used in one of three roles: (a) as a hole, (b) as a label,
   * or (c) as an object-level variable bound by an object-level quantifier.
   * In cases (a) and (b), we mark the variable as hole or label when
   * parsing the hole(Var) or label(Var) declaration, and introduce
   * it into the graph immediately. In case (c), we introduce a new
   * anonymous node whose label is the object variable.
   *
   * Case (c) is applied analogously for processing atomic arguments
   * of labelling atoms: introduce new anomyous node with this label.
   */

  private String makeAnonymousNode(String label) {
    String nodename = "hs" + (nextGensymIndex++);
    graph.addNode(nodename, new NodeData(NodeType.LABELLED));
    labels.addLabel(nodename, label);
    return nodename;
  }

  private void addHole(String x) {
    graph.addNode(x, new NodeData(NodeType.UNLABELLED));
  }

  private void addLabel(String x) {
    graph.addNode(x, new NodeData(NodeType.LABELLED));
  }

  private String lookupOrAnonymous(String x) {
    if( graph.hasNode(x) ) {
      return x;
    } else {
      return makeAnonymousNode(x);
    }
  }
}

PARSER_END(HolesemComsemInputCodec)


/*
 * lexical scanner
 */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <PERCENT_COMMENT: "%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>  
}

TOKEN :
{
    <HOLE  : "hole">
 |  <LABEL : "label">
 |  <SOME  : "some">
 |  <AND   : "and">
 |  <OR    : "or">
 |  <IMP   : "imp">
 |  <NOT   : "not">
 |  <ALL   : "all">
 |  <LEQ   : "leq">
 |  <PRED1 : "pred1">
 |  <PRED2 : "pred2">
 |  <PLATOM  : "\'" (~["\'"])* "\'"
  	   | ["a"-"z"] (["a"-"z", "A"-"Z", "0"-"9", "_", "\'", "&"])+>
 |  <PLVAR : ["A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_", "\'", "&"])+>

}




/*
 * grammar
 */

// start symbol: Input
void Input() : {
}
{
  // Input -> Term
  Term()
}

void Term() :
{
  String x,y,z,f;
  Token t;
}
{
  // Term -> and ( Term , Term )            (meta-level "and")
  LOOKAHEAD(3)          // need lookahead to distinguish from and(V,V,V) below
  <AND> "(" Term() "," Term() ")"
     // NOP


  // Term -> some ( Var, Term )             (meta-level "some")
| LOOKAHEAD(5)          // need lookahead to distinguish from some(V,V,V) below
  <SOME> "(" t=<PLVAR> "," Term() ")" 
     // NOP


  // Term -> hole ( Var )                   (meta-level hole declaration)
| <HOLE> "(" x=VariableAsHole() ")" 
    // NOP -- everything is done in VariableAsHole()


  // Term -> label ( Var )                  (meta-level label declaration)
| <LABEL> "(" x=VariableAsLabel() ")"
    // NOP -- everything is done in VariableAsLabel()


  // Term -> leq ( Var , Var )              (leq constraint)
| <LEQ> "(" x=Variable() "," y=Variable() ")" {
    graph.addEdge(y, x,
		  new EdgeData(EdgeType.DOMINANCE));
  }


  // Term -> pred1 ( Var , Atom , VarOrAtom )   (one-place labelling atom)
| <PRED1> "(" x=Variable() "," f=PrologAtom() "," y=VariableOrAtom() ")" {
    labels.addLabel(x, stripquotes(f));
    graph.addEdge(x, y, new EdgeData(EdgeType.TREE));
  }


  // Term -> pred2 ( Var , Atom , VarOrAtom, VarOrAtom )  (two-place labelling atom)
| <PRED2> "(" x=Variable() "," f=PrologAtom() "," y=VariableOrAtom() "," z=VariableOrAtom() ")" {
    labels.addLabel(x, stripquotes(f));
    graph.addEdge(x, y, new EdgeData(EdgeType.TREE));
    graph.addEdge(x, z, new EdgeData(EdgeType.TREE));
  }


  // Term -> LogicalConstant ( Var , Varlist )   (labelling atom for logical constants)
  | f=LogicalConstant() "(" x=Variable() "," Varlist() ")" {
    labels.addLabel(x, stripquotes(f));
    
    for( String child : varlist ) {
      graph.addEdge(x, child,
		    new EdgeData(EdgeType.TREE));
    }
    
    varlist.clear();
  }
}


  



String LogicalConstant() : { 
  Token t; 
}
{
  t=<AND>   { return t.image; }
| t=<OR>    { return t.image; }
| t=<IMP>   { return t.image; }
| t=<NOT>   { return t.image; }
| t=<ALL>   { return t.image; }
| t=<SOME>  { return t.image; }
}


String PrologAtom() : { 
  Token t; 
  String s;
}
{
  s=LogicalConstant() {
    return s;
  }

| t=<HOLE> | t=<LABEL> | t=<PRED1> | t=<PRED2> | t=<PLATOM> {
    return t.image;
  }
}

void Varlist() :
{
  String t,u;
}
{
  // Varlist -> Variable [ (, Variable)+ ]
  (t=VariableOrAtom() {varlist.add(t);}) ("," u=VariableOrAtom() {varlist.add(u);})*
}


String VariableOrAtom() : {
  String s;
  Token t;
}
{
  // can be a variable -- in that case, the node has been computed
  // by the Variable() rule below
  s=Variable() { return s; } 


  // can be an atom -- in that case, introduce an anonymous labelled node
| s=PrologAtom() {
  return makeAnonymousNode(s);
  }
}
    

String Variable() :
{
  Token t;
}
{
  // Variable -> PLVAR
  t=<PLVAR>
  {
    // If the variable has been declared as a hole or label, just return
    // this variable. Otherwise, it is an object-level variable, and return
    // an anonymous labelled node.
    return lookupOrAnonymous(t.image);
  }
}

String VariableAsHole() : {
  Token t;
}
{
  // A variable in the context of a hole(Var) declaration is declared
  // as a hole.
  t=<PLVAR> {
    String s = t.image;
    addHole(s);
    return s;
  }
}


String VariableAsLabel() : {
  Token t;
}
{
  // A variable in the context of a label(Var) declaration is declared
  // as a label.
  t = <PLVAR> {
    String s = t.image;
    addLabel(s);
    return s;
  }
}
