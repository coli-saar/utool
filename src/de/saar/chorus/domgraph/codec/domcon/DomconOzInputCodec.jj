options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(DomconOzInputCodec)

package de.saar.chorus.domgraph.codec.domcon;

import java.io.*;
import java.util.*;

import de.saar.chorus.domgraph.graph.*;
import de.saar.chorus.domgraph.codec.*;

import org.testng.annotations.ExpectedExceptions;
import org.testng.annotations.Test;


/**
 * An input codec for weakly normal dominance constraints in Oz syntax. The
 * inputs that this codec accepts are lists of Oz terms; these terms
 * represent dominance and labelling atoms.<p>
 *
 * An example input looks as follows:<p>
 * <code>[label(x f(y)) dom(y z) label(z a)]</code><p>
 *
 * The dominance constraint represented by the Oz term is read as a
 * weakly normal dominance constraint, i.e. we require that the
 * right-hand sides of dominance atoms are roots, and we assume that
 * there is an implicit inequality atom for each pair of labelled
 * variables.<p>
 *
 * The constraints accepted by this codec are compatible with the
 * old CHORUS demo. A line that starts with a percent sign is
 * interpreted as a comment.
 * 
 * @author Alexander Koller
 *
 */
@CodecMetadata(name="domcon-oz", extension=".clls")
public class DomconOzInputCodec extends InputCodec {
    private DomGraph graph;
    private NodeLabels labels;
  private List<String> varlist;
 
    public DomconOzInputCodec() {
	this((Reader) null);
	varlist = new ArrayList<String>();
    }
    
    public void decode(Reader inputStream, DomGraph graph, NodeLabels labels)
	throws IOException, ParserException, MalformedDomgraphException {

	this.graph = graph;
	this.labels = labels;

	graph.clear();
	labels.clear();
	varlist.clear();

	try {
	    ReInit(inputStream);
	    Input();
	} catch(Throwable e) {
//	    e.printStackTrace(System.err);
	    throw new ParserException(e);
	}
    }


    private String stripquotes(String label) {
	if( label.startsWith("\'") ) {
	    // strip off first and last character
	    return label.substring(1, label.length()-1);
	} else {
	    return label;
	}
    }
    
    

    /**************************************************************
     * UNIT TESTS
     **************************************************************/
    @Test(groups = {"Domgraph"})
    public class UnitTests {
    	public void chain3() throws Exception {
    		DomGraph graph = new DomGraph();
    		NodeLabels labels = new NodeLabels();
    		
    		DomGraph myGraph = new DomGraph();
    		NodeLabels myLabels = new NodeLabels();
    		DomconOzInputCodec codec = new DomconOzInputCodec();
    		codec.decode(new StringReader("[label(y0 a0) label(x1 f1(xl1 xr1)) label(y1 a1) label(x2 f2(xl2 xr2))\n"
    		 + "label(y2 a2) label(x3 f3(xl3 xr3)) label(y3 a3) dom(xl1 y0) \n"
    		 + "dom(xr1 y1) dom(xl2 y1) dom(xr2 y2) dom(xl3 y2) dom(xr3 y3)]"),
    		 myGraph, myLabels);
    		
	        graph.addNode("y0", new NodeData(NodeType.LABELLED));
	        labels.addLabel("y0", "a0");
	        graph.addNode("x1", new NodeData(NodeType.LABELLED));
	        labels.addLabel("x1", "f1");
	        graph.addNode("xl1", new NodeData(NodeType.UNLABELLED));
	        graph.addNode("xr1", new NodeData(NodeType.UNLABELLED));
	        graph.addNode("y1", new NodeData(NodeType.LABELLED));
	        labels.addLabel("y1", "a1");
	        graph.addNode("x2", new NodeData(NodeType.LABELLED));
	        labels.addLabel("x2", "f2");
	        graph.addNode("xl2", new NodeData(NodeType.UNLABELLED));
	        graph.addNode("xr2", new NodeData(NodeType.UNLABELLED));
	        graph.addNode("y2", new NodeData(NodeType.LABELLED));
	        labels.addLabel("y2", "a2");
	        graph.addNode("x3", new NodeData(NodeType.LABELLED));
	        labels.addLabel("x3", "f3");
	        graph.addNode("xl3", new NodeData(NodeType.UNLABELLED));
	        graph.addNode("xr3", new NodeData(NodeType.UNLABELLED));
	        graph.addNode("y3", new NodeData(NodeType.LABELLED));
	        labels.addLabel("y3", "a3");

	        graph.addEdge("x1", "xl1", new EdgeData(EdgeType.TREE));
	        graph.addEdge("x1", "xr1", new EdgeData(EdgeType.TREE));
	        graph.addEdge("xl1", "y0", new EdgeData(EdgeType.DOMINANCE));
	        graph.addEdge("xr1", "y1", new EdgeData(EdgeType.DOMINANCE));
	        graph.addEdge("x2", "xl2", new EdgeData(EdgeType.TREE));
	        graph.addEdge("x2", "xr2", new EdgeData(EdgeType.TREE));
	        graph.addEdge("xl2", "y1", new EdgeData(EdgeType.DOMINANCE));
	        graph.addEdge("xr2", "y2", new EdgeData(EdgeType.DOMINANCE));
	        graph.addEdge("x3", "xl3", new EdgeData(EdgeType.TREE));
	        graph.addEdge("x3", "xr3", new EdgeData(EdgeType.TREE));
	        graph.addEdge("xl3", "y2", new EdgeData(EdgeType.DOMINANCE));
	        graph.addEdge("xr3", "y3", new EdgeData(EdgeType.DOMINANCE));
	        
	        assert DomGraph.isEqual(graph, labels, myGraph, myLabels);
    	}
    }	

}

PARSER_END(DomconOzInputCodec)


/*
 * lexical scanner
 */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <PERCENT_COMMENT: "%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>  
}

TOKEN :
{
    <LABEL : "label">
 |  <DOM   : "dom">
 |  <OZATOM  : "\'" (~["\'"])* "\'"
  	   | (["a"-"z", "A"-"Z", "0"-"9", "_", "\'", "&","�","�","�","�","�","�","�"])+>

}




/*
 * grammar
 */

// start symbol: Input
void Input() :
{}
{
  // Input -> [ Atom+ ]
    "[" (Atom())+ "]"
}

void Atom() :
{
  String x,y;
  Token f;
}
{
  // Atom -> DOM ( Variable Variable )
    <DOM> "(" x=Variable() y=Variable() ")"
     { 
	 graph.addEdge(x, y, 
		       new EdgeData(EdgeType.DOMINANCE));
     }


  // Atom -> LABEL ( Variable OZATOM [ ( Varlist ) ] )
 | <LABEL> "(" x=Variable() f=<OZATOM> [ "(" Varlist() ")"  ] ")"
    {
      // INVARIANT: varlist is empty each time we start recognising
      // a labelling atom. It is filled while parsing the Varlist.

	graph.getData(x).setType(NodeType.LABELLED);
	labels.addLabel(x, stripquotes(f.image));

	for( String child : varlist ) {
	    graph.addEdge(x, child,
			  new EdgeData(EdgeType.TREE));
	}

	varlist.clear();
    }
}

void Varlist() :
{
  String t;
}
{
  // Varlist -> Variable +
    (t=Variable() {varlist.add(t);})+
}



String Variable() :
{
  Token t;
}
{
  // Variable -> OZATOM
  t=<OZATOM>
  {
    String nodename = stripquotes(t.image);

    if( !graph.hasNode(nodename) ) {
      graph.addNode(nodename, new NodeData(NodeType.UNLABELLED));
    }

    return nodename;
  }
}
