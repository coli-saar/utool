options {
  LOOKAHEAD = 2;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  JDK_VERSION = "1.5";
}
PARSER_BEGIN(GlueInputCodec)



package de.saar.chorus.domgraph.codec.glue;

import java.io.*;
import java.util.*;

import de.saar.chorus.domgraph.codec.*;
import de.saar.chorus.domgraph.graph.*;



/**
 * An experimental input codec for LFG-style Glue Semantics 
 * axiom sets. The purpose of this codec is for experimenting
 * with different translations of Glue to dominance graphs in
 * the context of Etienne's MSc thesis.<p>
 *
 * The concrete syntax of the input is ad-hoc and doesn't reflect
 * the format of the formulas computed by the XLE. Glue formulas
 * can be built up from variables (starting with uppercase letters),
 * atoms (starting with lowercase letters), and the implication
 * symbol <code>-o</code>. If the antecedent of an implication is not atomic
 * (i.e. not an atom or a variable), then it must be surrounded by
 * brackets. The consequent of an implication may <i>never</i> be
 * in brackets. We will presumably switch to a different concrete
 * syntax at some point, so there's no point in making the parser
 * perfect right now.<p>
 *
 * An example input looks as follows:<p>
 * <code>[(((X -o z) -o w) -o a) -o Y, (X -o a) -o b -o c, Y]</code><p>
 *
 * @author Alexander Koller
 * @author Etienne Ailloud
 *
 */
 
public class GlueInputCodec extends InputCodec {
	private DomGraph graph;
    private NodeLabels labels;
	
	private List<Formula> formulas;
	
	public static String getName() {
		return "glue";
	}
	
	public static String getExtension() {
		return ".glue";
	}
	
	
	public GlueInputCodec() {
	  this((Reader) null);
	  
	  formulas = new ArrayList<Formula>();
    }
	
	public List<Formula> suffixes(Formula f) {
		List suff = new ArrayList<Formula>();
	    switch ( f.getType() ) {
        case IMPLICATION:
        		suff.add(f);
                suff.add(suffixes(f.getSubformulas().get(1)));
                break;
        case ATOM:
        case VARIABLE:
                suff.add(f);
        }
        return suff;
	}

	public boolean isSuffix(Formula f, List<Formula> formulas) {
		for (int i = 0; i < formulas.size(); i++) {
			if ( suffixes(formulas.get(i)).contains(f) )	return true;
		}
		return false;
	}

    public int depth(Formula f) {
        switch ( f.getType() ) {
        case IMPLICATION:
                return depth(f.getSubformulas().get(1)) + 1;
        case ATOM:
        case VARIABLE:
                return 0;
        }
        return 0;
    }

/*	Subroutine z corresponds to the auxiliary mapping of formulas z in the paper;
	it modifies the graph g and labels l passed in parameter
*/

	private void z(int j, Formula phi, String address, DomGraph g, NodeLabels l, List<Formula> axioms) {
        switch ( phi.getType() ) {
        case IMPLICATION:
		Formula psi = phi.getSubformulas().get(0);
		Formula chi = phi.getSubformulas().get(1);
		NodeData conclusion = new NodeData(NodeType.LABELLED);
		NodeData premiss = new NodeData(NodeType.LABELLED);
		// Address may not be at this point the empty word
		String addr_cc = address.substring(0, address.length()-1);
		String addr_pr = addr_cc + "2";
		String name_cc = "X" + String.valueOf(j+1) + addr_cc;
		String name_pr = "X" + String.valueOf(j+1) + addr_pr;
		String name_impl = "X" + String.valueOf(j+1) + address;
		g.addNode(name_cc, conclusion);
        	l.addLabel(name_cc, "ie");
		g.addNode(name_pr, premiss);
		// Creates the labelling edges
		EdgeData left = new EdgeData(EdgeType.TREE);
		EdgeData right = new EdgeData(EdgeType.TREE);
		g.addEdge(name_cc, name_impl, left);
		g.addEdge(name_cc, name_pr, right);
        	if ( !isSuffix(psi, axioms) ) {
			l.addLabel(name_pr, "[" + psi.toString() + "]");
    	    		z(j, chi, addr_cc, g, l, formulas);
    	    	} else {
    	    		z(j, chi, addr_cc, g, l, formulas);
    		/* 	if psi is not a suffix, branching downward does not necessarily
			yield a label for the right-bottom node (corresp. to "premiss")
			(only if the downward recursion (subroutine w) is not trivial):
		*/
			premiss.setType(NodeType.UNLABELLED);
			w(j, psi, addr_pr, g, l);
		}
        case ATOM:
        case VARIABLE:
        //	should always match the following test - provided depth is computed accurately
            if ( address == "" ) break;
        }
	}

	private void w(int j, Formula phi, String address, DomGraph g, NodeLabels l) {
		switch ( phi.getType() ) {
		case IMPLICATION:
			Formula psi = phi.getSubformulas().get(0);
        		Formula chi = phi.getSubformulas().get(1);
			// same remark as above: a priori, the new node downward needs not be labelled
			NodeData conclusion = new NodeData(NodeType.UNLABELLED);
			String addr_cc = address + "1";
			String name_cc = "X" + String.valueOf(j+1) + addr_cc;
			g.addNode(name_cc, conclusion);
			// sets label for the implication-introduction node, previously defined
			String name_impl = "X" + String.valueOf(j+1) + address;
			NodeData implication = g.getData(name_impl);
			implication.setType(NodeType.LABELLED);
			l.addLabel(name_impl, "ii_<" + psi.toString() + ">");
			// creates the labelling edge
			EdgeData edge = new EdgeData(EdgeType.TREE);
			g.addEdge(name_impl, name_cc, edge);
			w(j, chi, addr_cc, g, l);
		case ATOM:
		case VARIABLE:
		}
	}

    public void decode(Reader inputStream, DomGraph graph, NodeLabels labels)
	throws IOException, ParserException, MalformedDomgraphException {
		this.graph = graph;
		this.labels = labels;

		graph.clear();
		labels.clear();
		formulas.clear();
		
		try {
	    	ReInit(inputStream);
		    list();
		    
		    
		    /*
		     * At this point, we have the LL formulas as members
		     * of the "formulas" field. This is where they would now
		     * have to be translated into the "graph" and "labels"
		     * objects. 
		     *
		     * Etienne, feel free to implement any methods you want
		     * in this class or to put them into new classes in this
		     * package. Just be sure to not make them public.
		     */
		    
		    System.out.println(formulas);
		} catch(Throwable e) {
		    throw new ParserException(e);
		}
		
		for ( int i = 0; i < formulas.size(); i++ ) {
			Formula axiom = formulas.get(i);
                        
             /* Add first node, labelled with axiom and index; the name is also indexed by
			  * the formula's address (as many 1s as the implicative depth)
			  */
                        NodeData axNode = new NodeData(NodeType.LABELLED);
                        String axAddress;
						StringBuffer sb = new StringBuffer();
						for (int d = 0; d < depth(axiom); ++d) {
							sb.append("1");
						}
						axAddress = sb.toString();
                        String name = "X" + String.valueOf(i+1) + axAddress;
                        graph.addNode(name, axNode);
                        labels.addLabel(name, "ax_"+String.valueOf(i+1));
             
              /* Recursive call on the axiom formula
			   * (to simulate the auxiliary function z);
			   * expands the constraint ("graph" and "labels") obtained so far
			   */
                        z(i, axiom, axAddress, graph, labels, formulas);                        
		}
	}
}
PARSER_END(GlueInputCodec)



/*
 * lexical scanner
 */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <PERCENT_COMMENT: "%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>  
}

TOKEN :
{
   <IMP : "-o">
 | <VAR : ["A"-"Z"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
 | <ATOM : ["a"-"z"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}



void list() :
{ 
	Formula f;
}
{
	"[" (f=formula() { formulas.add(f); })
		("," f=formula() { formulas.add(f); })* "]"
}

Formula formula() :
{ 
	Formula sub1, sub2;
}
{
	"(" sub1=formula() ")" <IMP> sub2=formula() {
		return new Formula(Formula.Type.IMPLICATION, sub1, sub2);
	}

	| sub1=VarOrAtom() <IMP> sub2=formula() {
		return new Formula(Formula.Type.IMPLICATION, sub1, sub2);
	}
	
	| sub1=VarOrAtom() {
		return sub1;
	}
}


Formula VarOrAtom() :
{ 
	Token t;
}
{
	t=<VAR> {
		return new Formula(Formula.Type.VARIABLE, t.image);
	}
	
  | t=<ATOM> {
  		return new Formula(Formula.Type.ATOM, t.image);
  }
}

