/*
 * The hole semantics syntax is idiosyncratic in a number of ways which
 * make this codec a little messy.
 *
 * - The symbols "some" and "and" are used both for meta-level variable
 *   introduction and conjunction and as the heads of labelling atoms.
 *   We distinguish between the two types of usage by increasing the
 *   lookahead of the rules for the meta-level usage.
 *
 * - Prolog variables are used both as meta-level and as object-level
 *   variables. The latter are intended to introduce anonymous nodes
 *   labelled with this variable. We deal with this by keeping track
 *   of the meta-level variables (declared as "hole" or "label"),
 *   and introducing anonymous nodes by need.
 *
 * After the initial graph is constructed from the input file,
 * we postprocess it in the following ways:
 *
 * - Dominance edges pointing to non-roots have their targets moved
 *   up so they point to the respective roots.
 *
 * If anything goes wrong during these operations, or if the final
 * graph is not normal, the codec raises a MalformedDomgraphException.
 *
 */

options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
  
}

PARSER_BEGIN(HolesemComsemInputCodec)

package de.saar.chorus.domgraph.codec.holesem;

import java.io.*;
import java.util.*;

import de.saar.chorus.domgraph.graph.*;
import de.saar.chorus.domgraph.codec.*;
import org._3pq.jgrapht.Edge;


/**
 * An input codec for Hole Semantics. We use the concrete syntax
 * of the <a href="http://cslipublications.stanford.edu/site/1575864967.html">
 * Blackburn & Bos (2005) textbook</a> on computational semantics.
 * The codec is thus able to process the USRs generated by the software
 * described in that book.<p>
 *
 * The codec implements the translation of Hole Semantics to normal
 * dominance graphs described in 
 * <a href="http://www.coli.uni-saarland.de/~koller/showpaper.php?id=hs-as-dc">
 * Koller et al., EACL 2003</a>. See {@link #decode(Reader,DomGraph,NodeLabels)}
 * for details. <p>
 *
 * An example input for this codec looks as follows:<br/>
 * {@code some(_A,some(_B,some(_C,and(label(_A),and(hole(_B),} <br/>
 * &nbsp; {@code and(label(_C),and(some(_A,X,_B),and(pred1(_C,foo,X),leq(_C,_B)))))))))} 
 *
 * @author Alexander Koller
 */



@CodecMetadata(name="holesem-comsem", extension=".hs.pl")
public class HolesemComsemInputCodec extends InputCodec {
	public static final int ERROR_GRAPH_NOT_NORMAL = 1;
	public static final int ERROR_GRAPH_NOT_HNC = 2;
	public static final int ERROR_GRAPH_NOT_LEAF_LABELLED = 3;
	public static final int ERROR_MULTIPLE_PARENTS = 4;
	
    private DomGraph graph;
    private NodeLabels labels;
  private List<String> varlist;
  private int nextGensymIndex;
	
	@CodecConstructor
    public HolesemComsemInputCodec() {
	this((Reader) null);

	varlist = new ArrayList<String>();
    }
    
    
     /**
     * Reads an USR representation from a <code>Reader</code>. This method
     * converts the USR into an equivalent labelled dominance graph and
     * stores this graph in a <code>DomGraph</code> and the labels in
     * a <code>NodeLabels</code> object.<p>
     *
     * This method converts a Hole Semantics USR into a dominance graph.
     * It will then normalise this graph by moving the lower ends of
     * dominance edges up to the respective roots. The resulting graph
     * is guaranteed to be a correct encoding of the original USR (in
     * that the pluggings of the USR correspond to the solved forms of
     * the dominance graph) if the normalised dominance graph is hypernormally
     * connected. If it isn't, then the method throws a 
     * {@link de.saar.chorus.domgraph.codec.MalformedDomgraphException}.<p>
     *
     * @param reader the reader from which the USR is read
     * @param graph the dominance graph into which the USR is converted
     * @param labels the node labels of the labelled dominance graph
     * @throws IOException if an I/O error occurred while reading from <code>reader</code>
     * @throws ParserException if a syntactic error occurred while parsing the USR
     * @throws MalformedDomgraphException if the graph cannot be normalised,
     * or the result is not hypernormally connected.
     */
    public void decode(Reader reader, DomGraph graph, NodeLabels labels)
	throws IOException, ParserException, MalformedDomgraphException {
        List<String> topNodes = new ArrayList<String>();

	this.graph = graph;
	this.labels = labels;

	graph.clear();
	labels.clear();
	varlist.clear();

	nextGensymIndex = 1;

	try {
	    ReInit(reader);
	    Input();
	} catch(Throwable e) {
	    throw new ParserException(e);
	}

	// move dom edges up to roots
	List<Edge> allEdges = new ArrayList<Edge>();
	allEdges.addAll(graph.getAllEdges());

	for( int i = 0; i < allEdges.size(); i++ ) {
	  Edge edge = allEdges.get(i);

	  if( graph.getData(edge).getType() == EdgeType.DOMINANCE ) {
	    if( !graph.isRoot((String) edge.getTarget()) ) {
	      EdgeData data = graph.getData(edge);
	      String src = (String) edge.getSource();
	      String rootOfTarget = (String) edge.getTarget();

	      while( !graph.isRoot(rootOfTarget) ) {
		List<String> parents = graph.getParents(rootOfTarget, EdgeType.TREE);
		if( parents.size() > 1 ) {
		  throw new MalformedDomgraphException("The graph contains a node with multiple parents", ERROR_MULTIPLE_PARENTS);
		} else {
		  rootOfTarget = parents.get(0);
		}
	      }

	      // System.err.println("Move target of " + edge + " to " + rootOfTarget);
	      graph.remove(edge);
	      graph.addEdge(src, rootOfTarget, data);
	    }
	  }
	}
	
	CodecTools.graphLabelsConsistencyAssertion(graph, labels);
	CodecTools.removeTopEmptyFragment(graph, ERROR_GRAPH_NOT_NORMAL);
	
	// at this point, the graph must be normal; otherwise, the
	// encoding was not applicable in the first place.
	if( !graph.isNormal() ) {
	  throw new MalformedDomgraphException("The graph is not normal", ERROR_GRAPH_NOT_NORMAL);
	}

	// likewise for hnc and ll
	if( !graph.isHypernormallyConnected() ) {
	    throw new MalformedDomgraphException("The graph is not hypernormally connected", ERROR_GRAPH_NOT_HNC);
	}

	if( !graph.isLeafLabelled() ) {
	    throw new MalformedDomgraphException("The graph is not leaf-labelled", ERROR_GRAPH_NOT_LEAF_LABELLED);
	}
    }


    private String stripquotes(String label) {
	if( label.startsWith("\'") ) {
	    // strip off first and last character
	    return label.substring(1, label.length()-1);
	} else {
	    return label;
	}
    }


  /*
   * Management of holes, labels, and anonymous nodes.
   *
   * One complication in the holesem syntax is that a Prolog variable
   * can be used in one of three roles: (a) as a hole, (b) as a label,
   * or (c) as an object-level variable bound by an object-level quantifier.
   * In cases (a) and (b), we mark the variable as hole or label when
   * parsing the hole(Var) or label(Var) declaration, and introduce
   * it into the graph immediately. In case (c), we introduce a new
   * anonymous node whose label is the object variable.
   *
   * Case (c) is applied analogously for processing atomic arguments
   * of labelling atoms: introduce new anomyous node with this label.
   */

  private String makeAnonymousNode(String label) {
    String nodename = "hs" + (nextGensymIndex++);
    graph.addNode(nodename, new NodeData(NodeType.LABELLED));
    labels.addLabel(nodename, label);
    return nodename;
  }

  private void addHole(String x) {
    graph.addNode(x, new NodeData(NodeType.UNLABELLED));
  }

  private void addLabel(String x) {
    graph.addNode(x, new NodeData(NodeType.LABELLED));
  }

  private String lookupOrAnonymous(String x) {
    if( graph.hasNode(x) ) {
      return x;
    } else {
      return makeAnonymousNode(x);
    }
  }
}

PARSER_END(HolesemComsemInputCodec)


/*
 * lexical scanner
 */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <PERCENT_COMMENT: "%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>  
}

TOKEN :
{
    <HOLE  : "hole">
 |  <LABEL : "label">
 |  <SOME  : "some">
 |  <AND   : "and">
 |  <OR    : "or">
 |  <IMP   : "imp">
 |  <NOT   : "not">
 |  <ALL   : "all">
 |  <LEQ   : "leq">
 |  <QUE   : "que">
 |  <EQ    : "eq">
 |  <PRED1 : "pred1">
 |  <PRED2 : "pred2">
 |  <PLATOM  : "\'" (~["\'"])* "\'"
  	   | ["a"-"z"] (["a"-"z", "A"-"Z", "0"-"9", "_", "\'", "&"])*>
 |  <PLVAR : ["A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_", "\'", "&"])*>

}




/*
 * grammar
 */

// start symbol: Input
void Input() : {
}
{
  // Input -> Term
  Term()
}

void Term() :
{
  String x,y,z,f;
  Token t;
}
{
  // Term -> and ( Term , Term )            (meta-level "and")
  LOOKAHEAD(3)          // need lookahead to distinguish from and(V,V,V) below
  <AND> "(" Term() "," Term() ")"
     // NOP


  // Term -> some ( Var, Term )             (meta-level "some")
| LOOKAHEAD(5)          // need lookahead to distinguish from some(V,V,V) below
  <SOME> "(" t=<PLVAR> "," Term() ")" 
     // NOP


  // Term -> hole ( Var )                   (meta-level hole declaration)
| <HOLE> "(" x=VariableAsHole() ")" 
    // NOP -- everything is done in VariableAsHole()


  // Term -> label ( Var )                  (meta-level label declaration)
| <LABEL> "(" x=VariableAsLabel() ")"
    // NOP -- everything is done in VariableAsLabel()


  // Term -> leq ( Var , Var )              (leq constraint)
| <LEQ> "(" x=Variable() "," y=Variable() ")" {
    graph.addEdge(y, x,
		  new EdgeData(EdgeType.DOMINANCE));
  }


  // Term -> pred1 ( Var , Atom , VarOrAtom )   (one-place labelling atom)
| <PRED1> "(" x=Variable() "," f=PrologAtom() "," y=VariableOrAtom() ")" {
    labels.addLabel(x, stripquotes(f));
    graph.addEdge(x, y, new EdgeData(EdgeType.TREE));
  }


  // Term -> pred2 ( Var , Atom , VarOrAtom, VarOrAtom )  (two-place labelling atom)
| <PRED2> "(" x=Variable() "," f=PrologAtom() "," y=VariableOrAtom() "," z=VariableOrAtom() ")" {
    labels.addLabel(x, stripquotes(f));
    graph.addEdge(x, y, new EdgeData(EdgeType.TREE));
    graph.addEdge(x, z, new EdgeData(EdgeType.TREE));
  }


  // Term -> LogicalConstant ( Var , Varlist )   (labelling atom for logical constants)
  | f=LogicalConstant() "(" x=Variable() "," Varlist() ")" {
    labels.addLabel(x, stripquotes(f));
    
    for( String child : varlist ) {
      graph.addEdge(x, child,
		    new EdgeData(EdgeType.TREE));
    }
    
    varlist.clear();
  }
 }


  



String LogicalConstant() : { 
  Token t; 
}
{
  t=<AND>   { return t.image; }
| t=<OR>    { return t.image; }
| t=<IMP>   { return t.image; }
| t=<NOT>   { return t.image; }
| t=<ALL>   { return t.image; }
| t=<SOME>  { return t.image; }
| t=<QUE>  { return t.image; }
| t=<EQ>  { return t.image; }
}

String PrologAtom() : { 
  Token t; 
  String s;
}
{
  s=LogicalConstant() {
    return s;
  }

| t=<HOLE> | t=<LABEL> | t=<PRED1> | t=<PRED2> | t=<PLATOM> {
    return stripquotes(t.image);
  }
}

void Varlist() :
{
  String t,u;
}
{
  // Varlist -> Variable [ (, Variable)+ ]
  (t=VariableOrAtom() {varlist.add(t);}) ("," u=VariableOrAtom() {varlist.add(u);})*
}


String VariableOrAtom() : {
  String s;
  Token t;
}
{
  // can be a variable -- in that case, the node has been computed
  // by the Variable() rule below
  s=Variable() { return s; } 


  // can be an atom -- in that case, introduce an anonymous labelled node
| s=PrologAtom() {
  return makeAnonymousNode(s);
  }
}
    

String Variable() :
{
  Token t;
}
{
  // Variable -> PLVAR
  t=<PLVAR>
  {
    // If the variable has been declared as a hole or label, just return
    // this variable. Otherwise, it is an object-level variable, and return
    // an anonymous labelled node.
    return lookupOrAnonymous(stripquotes(t.image));
  }
}

String VariableAsHole() : {
  Token t;
}
{
  // A variable in the context of a hole(Var) declaration is declared
  // as a hole.
  t=<PLVAR> {
    String s = stripquotes(t.image);
    addHole(s);
    return s;
  }
}


String VariableAsLabel() : {
  Token t;
}
{
  // A variable in the context of a label(Var) declaration is declared
  // as a label.
  t = <PLVAR> {
    String s = stripquotes(t.image);
    addLabel(s);
    return s;
  }
}
